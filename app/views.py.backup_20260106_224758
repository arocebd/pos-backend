# app/views.py
from decimal import Decimal
import io
from datetime import date, timedelta, timezone
from datetime import datetime, date as _date, datetime as _datetime
from django.core.exceptions import FieldError
from openpyxl import Workbook


from django.db import transaction
from django.db.models import Q, Sum, Count, F, DecimalField, ExpressionWrapper, Value as V
from django.db.models.functions import TruncDate, Coalesce
from django.http import JsonResponse, HttpResponse, request
from django.shortcuts import get_object_or_404
from django_filters.rest_framework import DjangoFilterBackend
from django.contrib.auth import get_user_model

from rest_framework.exceptions import PermissionDenied
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework import serializers, viewsets, filters, permissions, status
from rest_framework.decorators import api_view, action, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from rest_framework.generics import CreateAPIView
from rest_framework.pagination import PageNumberPagination
from rest_framework_simplejwt.authentication import JWTAuthentication

from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from rest_framework import status
from django.contrib.auth.hashers import make_password

from .models import (
    Product, ProductVariant, Category, Sale, Customer, SaleItem, Expense, Supplier, CustomerPayment,
    Purchase, PurchaseItem, SupplierPayment, Shop, UserProfile, PaymentRequest, StockLedger, CashTransaction
)
from .serializers import (
    ProductSerializer, ProductVariantSerializer, CategorySerializer, SaleSerializer,
    CustomerSerializer, ExpenseSerializer, SupplierSerializer, UserProfileSerializer,
    PurchaseSerializer, PurchaseItemSerializer, SupplierPaymentSerializer, CustomerPaymentSerializer,
    ShopRegistrationSerializer, PaymentRequestSerializer, SubscriptionStatusSerializer, UserProfileSerializer,
    ShopSerializer, CashTransactionSerializer, CashTransactionCreateSerializer
)

User = get_user_model()

# ============================================================
# RBAC (ROLE-BASED ACCESS CONTROL)
# ============================================================
SAFE_METHODS = ("GET", "HEAD", "OPTIONS")
WRITE_ACTIONS = {"create", "update", "partial_update", "destroy"}


def _normalized_role(profile) -> str:
    if not profile:
        return ""
    role = getattr(profile, "role", "")
    role = str(role) if role else ""
    role = role.lower()
    return "seller" if role == "cashier" else role


def _deny(detail: str) -> Response:
    return Response({"detail": detail}, status=status.HTTP_403_FORBIDDEN)


def enforce_feature(request, feature: str, *, write: bool) -> Response | None:
    profile = getattr(request.user, "profile", None)
    
    # Owners always have access to everything
    if profile and profile.is_owner:
        return None
    
    role = _normalized_role(profile)

    if role == "admin":
        return None

    if role == "manager":
        if feature == "user_management" and write:
            return _deny("Managers cannot create/update/delete users.")
        return None

    if role == "seller" or role == "cashier":
        # Check specific permissions for sellers/cashiers
        if feature == "products":
            if write and not profile.can_manage_products:
                return _deny("You don't have permission to manage products.")
            if not write and not profile.can_manage_products:
                # Allow read access for POS
                return None
            return None
        
        if feature == "pos" or feature == "customers":
            if not profile.can_manage_sales:
                return _deny("You don't have permission to manage sales.")
            return None
        
        if feature == "purchases" or feature == "suppliers":
            if not profile.can_manage_purchases:
                return _deny("You don't have permission to manage purchases.")
            return None
        
        if feature == "reports":
            if not profile.can_view_reports:
                return _deny("You don't have permission to view reports.")
            return None
        
        if feature == "user_management":
            return _deny("You don't have permission to manage users.")
        
        return _deny("You don't have permission to access this section.")

    return _deny("You don't have permission to access this section.")


class RoleBasedAccessPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        if not request.user or not request.user.is_authenticated:
            return False

        feature = getattr(view, "required_feature", None)
        if not feature:
            return True

        write = request.method not in SAFE_METHODS
        action = getattr(view, "action", None)
        if action in WRITE_ACTIONS:
            write = True
        elif action is not None:
            write = False

        return enforce_feature(request, feature, write=write) is None


# ------------------------------------------------------------
# SHOP FILTER MIXIN FOR MULTI-TENANCY
# ------------------------------------------------------------
class ShopFilterMixin:
    """Mixin to filter queryset by current user's shop"""
    
    def get_queryset(self):
        qs = super().get_queryset()
        if self.request.user.is_authenticated:
            profile = getattr(self.request.user, 'profile', None)
            if profile and profile.shop:
                return qs.filter(shop=profile.shop)
        return qs.none()  # Return empty if no shop


# -----------------------------
# Category & Product
# -----------------------------
class CategoryViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Category.objects.all().order_by("name")
    serializer_class = CategorySerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    filter_backends = [filters.SearchFilter]
    search_fields = ["name"]
    required_feature = "products"


class ProductViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Product.objects.select_related("category").order_by("-id")
    serializer_class = ProductSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    filter_backends = [filters.SearchFilter]
    search_fields = ["title", "product_code", "sku", "barcode"]


class ProductVariantViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    """
    ViewSet for Product Variants
    Supports filtering by product_id via query param: ?product=<id>
    """
    queryset = ProductVariant.objects.select_related("product").order_by("-id")
    serializer_class = ProductVariantSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    filter_backends = [filters.SearchFilter]
    search_fields = ["variant_name", "sku", "barcode", "product__title"]
    
    def get_queryset(self):
        qs = ProductVariant.objects.select_related("product").order_by("-id")
        if self.request.user.is_authenticated:
            profile = getattr(self.request.user, 'profile', None)
            if profile and profile.shop:
                qs = qs.filter(product__shop=profile.shop)
        else:
            qs = qs.none()
            
        # Filter by product if specified
        product_id = self.request.query_params.get('product', None)
        if product_id:
            qs = qs.filter(product_id=product_id)
        return qs


# -----------------------------
# Sales
# -----------------------------
class SaleViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Sale.objects.all().order_by("-id")
    serializer_class = SaleSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "pos"

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=False)
        if not serializer.is_valid():
            return Response(
                {"success": False, "errors": serializer.errors},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # Check if guest sale
        customer_data = request.data.get("customer_data")
        is_guest = customer_data is None
        
        # Handle customer
        customer = None
        if not is_guest and customer_data:
            phone = customer_data.get("phone", "").strip()
            name = customer_data.get("name", "").strip()
            
            if phone and name:
                customer, created = Customer.objects.get_or_create(
                    phone=phone,
                    shop=shop,
                    defaults={"name": name, "shop": shop}
                )
                if not created:
                    customer.name = name
                    customer.save(update_fields=["name"])
        
        items = request.data.get("items", [])
        product_ids = [i.get("product") for i in items if i.get("product")]
        products = {
            p.id: p
            for p in Product.objects.select_for_update().filter(id__in=product_ids, shop=shop)
        }

        # Stock check
        for item in items:
            pid = item.get("product")
            qty = int(item.get("quantity", 0))
            p = products.get(pid)
            if not p:
                return Response(
                    {"success": False, "error": f"Product ID {pid} not found"},
                    status=status.HTTP_404_NOT_FOUND,
                )
            if p.stock < qty:
                return Response(
                    {
                        "success": False,
                        "error": f"Insufficient stock for {p.title}. Available: {p.stock}",
                    },
                    status=status.HTTP_400_BAD_REQUEST,
                )

        # Get redeemed points
        redeemed_points = int(request.data.get("redeemed_points", 0))
        
        # Save sale
        sale = serializer.save(
            shop=shop,
            customer=customer,
            redeemed_points=redeemed_points
        )
        
        # Deduct stock
        for item in items:
            p = products[item["product"]]
            p.stock -= int(item["quantity"])
            p.save(update_fields=["stock"])
        
        # Calculate points earned
        total_points_earned = 0
        if customer:
            # Calculate earned points: 1 point per 100 Tk spent
            total_points_earned = int(sale.total / 100)
            
            # Update customer points (add earned, subtract redeemed)
            customer.points = customer.points + total_points_earned - redeemed_points
            customer.save(update_fields=["points"])

        return Response(
            {
                "success": True,
                "message": "Sale completed successfully, stock updated.",
                "data": {
                    **self.get_serializer(sale).data,
                    "earned_points": total_points_earned,
                    "redeemed_points": redeemed_points,
                },
            },
            status=status.HTTP_201_CREATED,
        )


@api_view(["GET"])
def product_lookup(request):
    """Lookup product by code or barcode (shop-scoped)"""
    code = request.query_params.get("code", "").strip()
    if not code:
        return Response({"error": "No code provided"}, status=400)

    # Get current shop
    profile = request.user.profile
    shop = profile.shop if profile else None
    
    try:
        product = Product.objects.get(
            Q(product_code__iexact=code) | Q(barcode__iexact=code),
            shop=shop
        )
        serializer = ProductSerializer(product, context={"request": request})
        return Response(serializer.data, status=200)
    except Product.DoesNotExist:
        return Response({"error": f"Product '{code}' not found"}, status=404)


# In invoice_view function:
@api_view(["GET"])
@permission_classes([IsAuthenticated])
def invoice_view(request, pk):
    sale = get_object_or_404(Sale, pk=pk)
    serializer = SaleSerializer(sale, context={"request": request})
    return Response(serializer.data)


# -----------------------------
# Customers
# -----------------------------
class StandardPagination(PageNumberPagination):
    page_size = 12
    page_size_query_param = 'page_size'
    max_page_size = 100

class CustomerViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Customer.objects.all().order_by("-id")
    serializer_class = CustomerSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "customers"
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ["name", "phone"]
    ordering_fields = ["name", "points", "id"]
    pagination_class = StandardPagination

    def get_queryset(self):
        qs = super().get_queryset()
    
        # Try different possible relationship names
        try:
        # First try 'sales' (most common custom name)
            qs = qs.annotate(sales_count=Count("sales"))
        except FieldError:
            try:
            # Then try 'sale_set' (Django default)
                qs = qs.annotate(sales_count=Count("sale_set"))
            except FieldError:
                try:
                # Try 'sale' (singular)
                    qs = qs.annotate(sales_count=Count("sale"))
                except FieldError:
                # If all fail, just return queryset without annotation
                    return qs
    
        return qs

    @action(detail=True, methods=["get"])
    def ledger(self, request, pk=None):
        customer = self.get_object()

        total_sales = Sale.objects.filter(customer=customer).aggregate(s=Sum("total"))["s"] or Decimal("0.00")
        total_paid_in_sale = Sale.objects.filter(customer=customer).aggregate(s=Sum("paid_amount"))["s"] or Decimal("0.00")
        total_repaid = CustomerPayment.objects.filter(customer=customer).aggregate(s=Sum("amount"))["s"] or Decimal("0.00")

        total_paid = total_paid_in_sale + total_repaid
        total_due = total_sales - total_paid

        entries = []

        sales = Sale.objects.filter(customer=customer).order_by("date", "id").prefetch_related("items__product")
        for s in sales:
            entries.append({
                "id": s.id,
                "model": "sale",
                "date": s.date.strftime("%Y-%m-%d"),
                "type": "Sale",
                "memo": f"INV-{s.id}",
                "total": float(s.total or 0),
                "paid_amount": float(s.paid_amount or 0),
                "due_amount": float(s.due_amount or 0),
                "payment_method": s.payment_method,
                "trx_id": s.trx_id,
                "items": [
                    {
                        "product": it.product.title,
                        "quantity": it.quantity,
                        "unit_price": float(it.price),
                        "total": float(it.total),
                    } for it in s.items.all()
                ],
                "debit": float(s.total or 0),
                "credit": 0.0,
                "balance": None,
            })

        payments = CustomerPayment.objects.filter(customer=customer).order_by("date", "id")
        for pay in payments:
            entries.append({
                "id": pay.id,
                "model": "payment",
                "date": pay.date.strftime("%Y-%m-%d"),
                "type": "Payment",
                "memo": pay.memo_no or "-",
                "remarks": pay.remarks or "",
                "amount": float(pay.amount or 0),
                "payment_method": pay.payment_method,
                "debit": 0.0,
                "credit": float(pay.amount or 0),
                "balance": None,
            })

        entries.sort(key=lambda r: (r["date"], r["type"] != "Sale"))

        running = 0.0
        for r in entries:
            running += (r.get("debit", 0.0) or 0.0) - (r.get("credit", 0.0) or 0.0)
            r["balance"] = float(running)

        return Response({
            "customer": {"id": customer.id, "name": customer.name, "phone": customer.phone},
            "summary": {
                "total_sales": float(total_sales),
                "total_paid": float(total_paid),
                "total_due": float(total_due),
            },
            "entries": entries,
        })

    @action(detail=True, methods=["post"])
    def repay(self, request, pk=None):
        customer = self.get_object()
        shop = request.user.profile.shop

        amount = Decimal(str(request.data.get("amount") or "0"))
        if amount <= 0:
            return Response({"detail": "Amount must be > 0"}, status=400)

        # Optional: block overpay
        total_sales = Sale.objects.filter(customer=customer).aggregate(s=Sum("total"))["s"] or Decimal("0.00")
        total_paid_in_sale = Sale.objects.filter(customer=customer).aggregate(s=Sum("paid_amount"))["s"] or Decimal("0.00")
        total_repaid = CustomerPayment.objects.filter(customer=customer).aggregate(s=Sum("amount"))["s"] or Decimal("0.00")
        current_due = total_sales - (total_paid_in_sale + total_repaid)

        if amount > current_due:
            return Response({"detail": f"Overpay not allowed. Current due is {current_due}"}, status=400)

        pay = CustomerPayment.objects.create(
            shop=shop,
            customer=customer,
            amount=amount,
            payment_method=request.data.get("payment_method") or "cash",
            memo_no=request.data.get("memo_no"),
            remarks=request.data.get("remarks"),
        )

        return Response({"success": True, "payment": CustomerPaymentSerializer(pay).data})

# customer lookup by phone
@api_view(["GET"])
def customer_lookup(request):
    phone = request.query_params.get("phone", "").strip()
    if not phone:
        return Response({"error": "No phone provided"}, status=400)
    # Get current shop
    profile = request.user.profile
    shop = profile.shop if profile else None
    
    try:
        customer = Customer.objects.get(phone=phone, shop=shop)
        serializer = CustomerSerializer(customer)
        return Response(serializer.data, status=200)
    except Customer.DoesNotExist:
        return Response({"message": "New customer"}, status=404)

# In views.py, add these imports at the top
from .models import CustomerPayment
from .serializers import CustomerPaymentSerializer

# Add CustomerPaymentViewSet
class CustomerPaymentViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = CustomerPayment.objects.all().order_by("-date", "-id")
    serializer_class = CustomerPaymentSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "customers"
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ["customer__name", "customer__phone", "memo_no"]
    filterset_fields = ["customer", "payment_method"]

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        payment = serializer.save()
        
        return Response({
            "success": True,
            "message": "Customer payment recorded successfully.",
            "data": self.get_serializer(payment).data,

        }, status=status.HTTP_201_CREATED)


# ============================================================
# CASH TRANSACTION EXPORT VIEWS (PDF & EXCEL)
# ============================================================

class CashTransactionExportPDF(ShopFilterMixin, APIView):
    """Export cash transactions to PDF"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        from reportlab.lib.pagesizes import A4
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
        from reportlab.lib.styles import getSampleStyleSheet
        from reportlab.lib import colors
        from io import BytesIO

        profile = request.user.profile
        shop = profile.shop if profile else None

        if not shop:
            return Response({"error": "No shop associated"}, status=400)

        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Build query
        queryset = CashTransaction.objects.filter(shop=shop).order_by('date', 'created_at')

        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])

        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )

        # Create PDF
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=30, bottomMargin=30)
        styles = getSampleStyleSheet()
        story = []

        # Title
        story.append(Paragraph(f"Cash Ledger Report - {shop.shop_name}", styles["Title"]))
        if start_date and end_date:
            story.append(Paragraph(f"Period: {start_date} to {end_date}", styles["Normal"]))
        story.append(Spacer(1, 20))

        # Summary table
        summary_data = [
            ["Summary", "Amount (৳)"],
            ["Total Credit (In)", f"{summary['total_credit']:.2f}"],
            ["Total Debit (Out)", f"{summary['total_debit']:.2f}"],
            ["Net Balance", f"{(summary['total_credit'] - summary['total_debit']):.2f}"],
        ]
        summary_table = Table(summary_data, colWidths=[200, 150])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3B82F6')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F3F4F6')),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ]))
        story.append(summary_table)
        story.append(Spacer(1, 20))

        # Transaction details header
        story.append(Paragraph("Transaction Details", styles["Heading2"]))
        story.append(Spacer(1, 10))

        # Transaction table
        table_data = [["Date", "Type", "Source", "Description", "Credit (৳)", "Debit (৳)"]]

        running_balance = Decimal('0.00')
        for t in queryset:
            credit = f"{t.amount:.2f}" if t.transaction_type == 'credit' else "—"
            debit = f"{t.amount:.2f}" if t.transaction_type == 'debit' else "—"
            desc = t.description[:30] + "..." if t.description and len(t.description) > 30 else (t.description or t.get_source_display())

            table_data.append([
                str(t.date),
                t.get_transaction_type_display(),
                t.get_source_display(),
                desc,
                credit,
                debit
            ])

        if len(table_data) > 1:
            trans_table = Table(table_data, colWidths=[70, 50, 80, 120, 70, 70])
            trans_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10B981')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F9FAFB')]),
            ]))
            story.append(trans_table)
        else:
            story.append(Paragraph("No transactions found for the selected period.", styles["Normal"]))

        doc.build(story)
        buffer.seek(0)

        response = HttpResponse(buffer, content_type="application/pdf")
        response["Content-Disposition"] = f'attachment; filename="cash_ledger_{start_date or "all"}_{end_date or "all"}.pdf"'
        return response


class CashTransactionExportExcel(ShopFilterMixin, APIView):
    """Export cash transactions to Excel"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO

        profile = request.user.profile
        shop = profile.shop if profile else None

        if not shop:
            return Response({"error": "No shop associated"}, status=400)

        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Build query
        queryset = CashTransaction.objects.filter(shop=shop).order_by('date', 'created_at')

        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])

        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )

        # Create workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Cash Ledger"

        # Styles
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="3B82F6", end_color="3B82F6", fill_type="solid")
        green_fill = PatternFill(start_color="10B981", end_color="10B981", fill_type="solid")
        thin_border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )

        # Title
        ws.append([f"Cash Ledger Report - {shop.shop_name}"])
        ws.merge_cells('A1:F1')
        ws['A1'].font = Font(bold=True, size=14)
        ws['A1'].alignment = Alignment(horizontal='center')

        if start_date and end_date:
            ws.append([f"Period: {start_date} to {end_date}"])
            ws.merge_cells('A2:F2')
            ws['A2'].alignment = Alignment(horizontal='center')

        ws.append([])  # Empty row

        # Summary section
        ws.append(["Summary", "Amount (৳)"])
        ws.append(["Total Credit (In)", float(summary['total_credit'])])
        ws.append(["Total Debit (Out)", float(summary['total_debit'])])
        ws.append(["Net Balance", float(summary['total_credit'] - summary['total_debit'])])

        ws.append([])  # Empty row

        # Transaction details header
        headers = ["Date", "Type", "Source", "Description", "Credit (৳)", "Debit (৳)", "Payment Method", "Reference"]
        ws.append(headers)
        header_row = ws.max_row
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=header_row, column=col)
            cell.font = header_font
            cell.fill = green_fill
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        # Transaction data
        for t in queryset:
            credit = float(t.amount) if t.transaction_type == 'credit' else ""
            debit = float(t.amount) if t.transaction_type == 'debit' else ""

            ws.append([
                str(t.date),
                t.get_transaction_type_display(),
                t.get_source_display(),
                t.description or t.get_source_display(),
                credit,
                debit,
                t.get_payment_method_display(),
                t.reference_no or ""
            ])

        # Adjust column widths
        ws.column_dimensions['A'].width = 12
        ws.column_dimensions['B'].width = 10
        ws.column_dimensions['C'].width = 18
        ws.column_dimensions['D'].width = 35
        ws.column_dimensions['E'].width = 12
        ws.column_dimensions['F'].width = 12
        ws.column_dimensions['G'].width = 15
        ws.column_dimensions['H'].width = 15

        # Save to buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)

        response = HttpResponse(
            buffer,
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        response["Content-Disposition"] = f'attachment; filename="cash_ledger_{start_date or "all"}_{end_date or "all"}.xlsx"'
        return response



# Add CustomerLedgerView
class CustomerLedgerView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request, customer_id):
        try:
            customer = Customer.objects.get(id=customer_id)
        except Customer.DoesNotExist:
            return Response({"error": "Customer not found"}, status=404)

        # Get all sales for this customer
        sales = Sale.objects.filter(customer=customer).order_by("date")
        
        # Get all payments for this customer
        payments = CustomerPayment.objects.filter(customer=customer).order_by("date")
        
        # Calculate totals
        total_sales = sales.aggregate(total=Coalesce(Sum("total"), V(0)))["total"]
        total_paid_from_sales = sales.aggregate(total=Coalesce(Sum("paid_amount"), V(0)))["total"]
        total_paid_from_payments = payments.aggregate(total=Coalesce(Sum("amount"), V(0)))["total"]
        total_paid = total_paid_from_sales + total_paid_from_payments
        total_due = total_sales - total_paid
        
        ledger = []
        
        # Add sales to ledger
        for sale in sales:
            ledger.append({
                "id": sale.id,
                "model": "sale",
                "date": str(sale.date),
                "type": "Sale",
                "invoice_no": f"INV-{sale.id}",
                "description": f"Sale #{sale.id}",
                "total": float(sale.total),
                "paid_amount": float(sale.paid_amount),
                "due_amount": float(sale.due_amount),
                "payment_method": sale.payment_method,
                "trx_id": sale.trx_id,
                "debit": float(sale.total),
                "credit": 0,
                "balance": None,
            })
        
        # Add payments to ledger
        for payment in payments:
            ledger.append({
                "id": payment.id,
                "model": "payment",
                "date": str(payment.date),
                "type": "Payment",
                "description": payment.remarks or "Payment Received",
                "memo_no": payment.memo_no or "-",
                "payment_method": payment.payment_method,
                "debit": 0,
                "credit": float(payment.amount),
                "balance": None,
            })
        
        # Sort by date and calculate running balance
        ledger = sorted(ledger, key=lambda x: x["date"])
        running = 0
        for row in ledger:
            running += row["debit"] - row["credit"]
            row["balance"] = running
        
        return Response({
            "customer": {
                "id": customer.id,
                "name": customer.name,
                "phone": customer.phone,
                "points": customer.points,
            },
            "totals": {
                "total_sales": float(total_sales),
                "total_paid": float(total_paid),
                "total_due": float(total_due),
            },
            "ledger": ledger,
        })

class CustomerLedgerDetailView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request, customer_id):
        try:
            customer = Customer.objects.get(id=customer_id, shop=request.user.profile.shop)
        except Customer.DoesNotExist:
            return Response({"error": "Customer not found"}, status=404)

        sales = Sale.objects.filter(customer=customer).order_by("date")
        
        payments = CustomerPayment.objects.filter(customer=customer).order_by("date")
        
        total_sales = sales.aggregate(total=Sum("total"))["total"] or Decimal("0.00")
        total_paid_from_sales = sales.aggregate(total=Sum("paid_amount"))["total"] or Decimal("0.00")
        total_paid_from_payments = payments.aggregate(total=Sum("amount"))["total"] or Decimal("0.00")
        total_paid = total_paid_from_sales + total_paid_from_payments
        total_due = total_sales - total_paid
        
        ledger = []
        
 
        for sale in sales:
            ledger.append({
                "id": sale.id,
                "type": "বিক্রয়",
                "date": sale.date.strftime("%Y-%m-%d"),
                "invoice_no": f"INV-{sale.id}",
                "description": f"Sale #{sale.id}",
                "total": float(sale.total),
                "paid_amount": float(sale.paid_amount),
                "due_amount": float(sale.due_amount),
                "payment_method": sale.payment_method,
                "trx_id": sale.trx_id,
                "debit": float(sale.total),
                "credit": 0.0,
                "balance": None,
            })
        
        for payment in payments:
            ledger.append({
                "id": payment.id,
                "type": "Payment",
                "date": payment.date.strftime("%Y-%m-%d"),
                "description": payment.remarks or "Payment Received",
                "memo_no": payment.memo_no or "-",
                "payment_method": payment.payment_method,
                "debit": 0.0,
                "credit": float(payment.amount),
                "balance": None,
            })
        
        ledger = sorted(ledger, key=lambda x: x["date"])
        running = Decimal("0.00")
        for row in ledger:
            running += Decimal(str(row["debit"])) - Decimal(str(row["credit"]))
            row["balance"] = float(running)
        
        return Response({
            "customer": {
                "id": customer.id,
                "name": customer.name,
                "phone": customer.phone,
                "points": customer.points,
            },
            "totals": {
                "total_sales": float(total_sales),
                "total_paid": float(total_paid),
                "total_due": float(total_due),
            },
            "ledger": ledger,
        })


# Add CustomerDueSummaryView
class CustomerDueSummaryView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        # Get all customers with their due amounts
        customers_with_due = []
        
        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        customers = Customer.objects.filter(shop=shop).order_by("name")
        
        for customer in customers:
            # Calculate customer's total due
            sales = Sale.objects.filter(customer=customer)
            payments = CustomerPayment.objects.filter(customer=customer)
            
            total_sales = sales.aggregate(total=Coalesce(Sum("total"), V(0)))["total"]
            total_paid_from_sales = sales.aggregate(total=Coalesce(Sum("paid_amount"), V(0)))["total"]
            total_paid_from_payments = payments.aggregate(total=Coalesce(Sum("amount"), V(0)))["total"]
            total_paid = total_paid_from_sales + total_paid_from_payments
            total_due = total_sales - total_paid
            
            if total_due > 0:
                customers_with_due.append({
                    "id": customer.id,
                    "name": customer.name,
                    "phone": customer.phone,
                    "total_due": float(total_due),
                    "last_sale_date": sales.last().date if sales.exists() else None,
                    "points": customer.points,
                })
        
        # Sort by highest due
        customers_with_due.sort(key=lambda x: x["total_due"], reverse=True)
        
        # Calculate grand total
        grand_total_due = sum(c["total_due"] for c in customers_with_due)
        
        return Response({
            "total_customers_with_due": len(customers_with_due),
            "grand_total_due": grand_total_due,
            "customers": customers_with_due,
        })


# -----------------------------
# KPI / Analytics
# -----------------------------
class SalesMetricsView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        today = date.today()
        start_of_month = today.replace(day=1)

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        today_total = (
            Sale.objects.filter(shop=shop, date__date=today).aggregate(total=Sum("total"))["total"]
            or 0
        )
        month_total = (
            Sale.objects.filter(shop=shop, date__date__gte=start_of_month).aggregate(
                total=Sum("total")
            )["total"]
            or 0
        )
        products_in_stock = (
            Product.objects.filter(shop=shop).aggregate(total=Sum("stock"))["total"] or 0
        )

        top_product = (
            SaleItem.objects.filter(sale__shop=shop, sale__date__date__gte=start_of_month)
            .values("product__id", "product__title")
            .annotate(
                qty=Sum("quantity"),
                total=Sum(
                    F("price") * F("quantity"),
                    output_field=DecimalField(max_digits=12, decimal_places=2),
                ),
            )
            .order_by("-qty")
            .first()
        )

        return Response(
            {
                "today_total": today_total,
                "month_total": month_total,
                "products_in_stock": products_in_stock,
                "top_product": {
                    "id": top_product["product__id"] if top_product else None,
                    "title": top_product["product__title"] if top_product else "",
                    "qty": top_product["qty"] if top_product else 0,
                    "total": top_product["total"] if top_product else 0,
                },
            }
        )


class DailySalesView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start = request.GET.get("from")
        end = request.GET.get("to")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None

        try:
            if not (start and end):
                today = date.today()
                start_d = today - timedelta(days=6)
                end_d = today
            else:
                start_d = datetime.strptime(start, "%Y-%m-%d").date()
                end_d = datetime.strptime(end, "%Y-%m-%d").date()
        except ValueError:
            return Response({"error": "from/to must be YYYY-MM-DD"}, status=400)

        qs = (
            Sale.objects.filter(shop=shop, date__date__range=[start_d, end_d])
            .annotate(day=TruncDate("date"))
            .values("day")
            .annotate(total=Sum("total"))
            .order_by("day")
        )
        data = [{"date": str(x["day"]), "total": x["total"] or 0} for x in qs]
        return Response(data)

class CategorySummaryView(APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start = request.GET.get("from")
        end = request.GET.get("to")

        shop = request.user.profile.shop

        if not (start and end):
            return Response({"detail": "from and to are required (YYYY-MM-DD)."}, status=400)

        qs = (
            SaleItem.objects.filter(sale__shop=shop, sale__date__date__range=[start, end])
            .values("product__category__name")
            .annotate(
                qty=Sum("quantity"),
                total=Sum(
                    F("price") * F("quantity"),
                    output_field=DecimalField(max_digits=12, decimal_places=2),
                ),
            )
            .order_by("-total")
        )

        data = [
            {
                "category": x["product__category__name"] or "Uncategorized",
                "qty": x["qty"] or 0,
                "total": x["total"] or 0,
            }
            for x in qs
        ]
        return Response(data)


class TopProductsView(APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start = request.GET.get("from")
        end = request.GET.get("to")
        limit = int(request.GET.get("limit", 5))

        shop = request.user.profile.shop

        if not (start and end):
            return Response({"detail": "from and to are required (YYYY-MM-DD)."}, status=400)

        qs = (
            SaleItem.objects.filter(sale__shop=shop, sale__date__date__range=[start, end])
            .values("product__id", "product__title")
            .annotate(
                qty=Sum("quantity"),
                total=Sum(
                    F("price") * F("quantity"),
                    output_field=DecimalField(max_digits=12, decimal_places=2),
                ),
            )
            .order_by("-qty")[:limit]
        )

        data = [
            {
                "id": x["product__id"],
                "title": x["product__title"],
                "qty": x["qty"] or 0,
                "total": x["total"] or 0,
            }
            for x in qs
        ]
        return Response(data)

class CategorySummaryView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start = request.GET.get("from")
        end = request.GET.get("to")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None

        qs = (
            SaleItem.objects.filter(sale__shop=shop, sale__date__date__range=[start, end])
            .values("product__category__name")
            .annotate(
                qty=Sum("quantity"),
                total=Sum(
                    F("price") * F("quantity"),
                    output_field=DecimalField(max_digits=12, decimal_places=2),
                ),
            )
            .order_by("-total")
        )

        data = [
            {
                "category": x["product__category__name"] or "Uncategorized",
                "qty": x["qty"] or 0,
                "total": x["total"] or 0,
            }
            for x in qs
        ]
        return Response(data)


class TopProductsView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start = request.GET.get("from")
        end = request.GET.get("to")
        limit = int(request.GET.get("limit", 5))

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None

        qs = (
            SaleItem.objects.filter(sale__shop=shop, sale__date__date__range=[start, end])
            .values("product__id", "product__title")
            .annotate(
                qty=Sum("quantity"),
                total=Sum(
                    F("price") * F("quantity"),
                    output_field=DecimalField(max_digits=12, decimal_places=2),
                ),
            )
            .order_by("-qty")[:limit]
        )

        data = [
            {
                "id": x["product__id"],
                "title": x["product__title"],
                "qty": x["qty"] or 0,
                "total": x["total"] or 0,
            }
            for x in qs
        ]
        return Response(data)


# -----------------------------
# Expenses
# -----------------------------
class ExpenseViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Expense.objects.all().order_by("-date", "-id")
    serializer_class = ExpenseSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "reports"
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    filterset_fields = ["category", "payment_method"]
    search_fields = ["category", "description"]

    def get_queryset(self):
        qs = super().get_queryset()
        f = self.request.query_params.get("from")
        t = self.request.query_params.get("to")
        if f and t:
            qs = qs.filter(date__range=[f, t])
        return qs


# In views.py, replace the ExpenseSummaryView class:

class ExpenseSummaryView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        f = request.GET.get("from")
        t = request.GET.get("to")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # Get filtered queryset
        qs = Expense.objects.filter(shop=shop)
        
        if f and t:
            qs = qs.filter(date__range=[f, t])

        category_rows = qs.values("category").annotate(total=Sum("amount")).order_by("-total")
        grand_total = qs.aggregate(total=Sum("amount"))["total"] or 0

        daily_rows = (
            qs.annotate(day=TruncDate("date"))
            .values("day")
            .annotate(total=Sum("amount"))
            .order_by("day")
        )

        return Response(
            {
                "grand_total": grand_total,
                "by_category": [
                    {"category": r["category"], "total": r["total"] or 0}
                    for r in category_rows
                ],
                "by_day": [{"date": str(r["day"]), "total": r["total"] or 0} for r in daily_rows],
            }
        )


# -----------------------------
# Supplier + Purchases
# -----------------------------
class SupplierViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Supplier.objects.all().order_by("name")
    serializer_class = SupplierSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "purchases"
    filter_backends = [filters.SearchFilter]
    search_fields = ["name", "phone"]

    @action(detail=True, methods=["get"])
    def ledger(self, request, pk=None):
        """GET /api/suppliers/<pk>/ledger/"""
        supplier = self.get_object()

        total_purchase = (
            Purchase.objects.filter(supplier=supplier).aggregate(s=Sum("total"))["s"] or 0
        )
        total_paid = (
            SupplierPayment.objects.filter(supplier=supplier).aggregate(s=Sum("amount"))["s"]
            or 0
        )
        total_due = total_purchase - total_paid

        entries = []

        purchases = Purchase.objects.filter(supplier=supplier).order_by("date", "id")
        for p in purchases:
            items = PurchaseItem.objects.filter(purchase=p).select_related("product")
            entries.append(
                {
                    "id": p.id,
                    "model": "purchase",
                    "date": p.date.strftime("%Y-%m-%d"),
                    "type": "Purchase",
                    "memo": p.invoice_no,
                    "remarks": p.remarks or "",
                    "subtotal": float(p.subtotal or 0),
                    "discount": float(p.discount or 0),
                    "total": float(p.total or 0),
                    "paid_amount": float(p.paid_amount or 0),
                    "due_amount": float(p.due_amount or 0),
                    "items": [
                        {
                            "product": it.product.title if it.product else str(it.product_variant),
                            "quantity": float(it.qty_packs),
                            "unit_price": float(it.price_per_pack),
                            "total": float(it.total),
                        }
                        for it in items
                    ],
                    "debit": float(p.total or 0),
                    "credit": 0.0,
                    "balance": None,
                }
            )

        payments = SupplierPayment.objects.filter(supplier=supplier).order_by("date", "id")
        for pay in payments:
            entries.append(
                {
                    "id": pay.id,
                    "model": "payment",
                    "date": pay.date.strftime("%Y-%m-%d"),
                    "type": "Payment",
                    "memo": pay.memo_no or "-",
                    "remarks": pay.remarks or "",
                    "amount": float(pay.amount or 0),
                    "payment_method": pay.payment_method,
                    "debit": 0.0,
                    "credit": float(pay.amount or 0),
                    "balance": None,
                }
            )

        entries.sort(key=lambda r: (r["date"], r["type"] != "Purchase"))
        running = 0.0
        for r in entries:
            running += (r.get("debit", 0.0) or 0.0) - (r.get("credit", 0.0) or 0.0)
            r["balance"] = float(running)

        return Response(
            {
                "supplier": supplier.name,
                "phone": supplier.phone,
                "address": supplier.address,
                "total_purchase": float(total_purchase),
                "total_paid": float(total_paid),
                "total_due": float(total_due),
                "ledger": entries,
            },
            status=status.HTTP_200_OK,
        )


class PurchaseViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = Purchase.objects.all().order_by("-date", "-id")
    serializer_class = PurchaseSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "purchases"
    filter_backends = [filters.SearchFilter]
    search_fields = ["invoice_no", "supplier__name"]

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        purchase = serializer.save()
        return Response(
            {
                "success": True,
                "message": "Purchase recorded successfully.",
                "data": self.get_serializer(purchase).data,
            },
            status=status.HTTP_201_CREATED,
        )
    
    def update(self, request, *args, **kwargs):
        kwargs['partial'] = True
        return super().update(request, *args, **kwargs)


class PurchaseItemViewSet(ShopFilterMixin, viewsets.ReadOnlyModelViewSet):
    queryset = PurchaseItem.objects.all().select_related("purchase", "product")
    serializer_class = PurchaseItemSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "purchases"


class SupplierPaymentViewSet(ShopFilterMixin, viewsets.ModelViewSet):
    queryset = SupplierPayment.objects.all().order_by("-date", "-id")
    serializer_class = SupplierPaymentSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    required_feature = "purchases"

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        payment = serializer.save()
        return Response(
            {
                "success": True,
                "message": "Supplier payment added successfully.",
                "data": self.get_serializer(payment).data,
            },
            status=status.HTTP_201_CREATED,
        )


class SupplierLedgerView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request, supplier_id):
        try:
            # Get current user's shop
            user_profile = getattr(request.user, 'profile', None)
            if not user_profile or not user_profile.shop:
                return Response({"error": "User has no associated shop"}, status=403)
            
            supplier = Supplier.objects.get(id=supplier_id, shop=user_profile.shop)
        except Supplier.DoesNotExist:
            return Response({"error": "Supplier not found"}, status=404)

        purchases = Purchase.objects.filter(supplier=supplier, shop=user_profile.shop).order_by("date")
        payments = SupplierPayment.objects.filter(supplier=supplier, shop=user_profile.shop).order_by("date")

        total_purchase = purchases.aggregate(total=Coalesce(Sum("total"), V(0)))["total"]
        total_paid = payments.aggregate(total=Coalesce(Sum("amount"), V(0)))["total"]
        total_due = total_purchase - total_paid

        ledger = []

        for p in purchases:
            items = PurchaseItem.objects.filter(purchase=p).select_related("product", "product_variant")
            item_list = [
                {
                    "product": it.product.title if it.product else str(it.product_variant),
                    "quantity": float(it.qty_packs),
                    "unit_price": float(it.price_per_pack),
                    "total": float(it.total),
                }
                for it in items
            ]
            ledger.append(
                {
                    "date": str(p.date),
                    "type": "Purchase",
                    "memo": p.invoice_no,
                    "remarks": p.remarks or "",
                    "subtotal": float(p.subtotal),
                    "discount": float(p.discount),
                    "total": float(p.total),
                    "paid_amount": float(p.paid_amount),
                    "due_amount": float(p.due_amount),
                    "items": item_list,
                    "debit": float(p.total),
                    "credit": 0,
                    "balance": None,
                }
            )

        for pay in payments:
            ledger.append(
                {
                    "date": str(pay.date),
                    "type": "Payment",
                    "memo": pay.memo_no or "-",
                    "remarks": pay.remarks or "",
                    "amount": float(pay.amount),
                    "method": pay.payment_method,
                    "debit": 0,
                    "credit": float(pay.amount),
                    "balance": None,
                }
            )

        ledger = sorted(ledger, key=lambda x: x["date"])
        running = 0
        for row in ledger:
            running += row["debit"] - row["credit"]
            row["balance"] = running

        return Response(
            {
                "supplier": supplier.name,
                "phone": supplier.phone,
                "address": supplier.address,
                "total_purchase": total_purchase,
                "total_paid": total_paid,
                "total_due": total_due,
                "ledger": ledger,
            }
        )


# -----------------------------
# Sales Report
# -----------------------------
@api_view(["GET"])
def sales_report(request):
    """Sales report with shop filtering"""
    # Get current shop
    profile = request.user.profile
    shop = profile.shop if profile else None
    
    start_date = request.GET.get("start_date")
    end_date = request.GET.get("end_date")
    report_type = request.GET.get("type", "summary").lower()
    export = request.GET.get("export")  # 'pdf' or 'excel'

    if not (start_date and end_date):
        return Response({"error": "Please provide start_date and end_date."}, status=400)

    try:
        start_d = datetime.strptime(start_date, "%Y-%m-%d").date()
        end_d = datetime.strptime(end_date, "%Y-%m-%d").date()
    except ValueError:
        return Response({"error": "Dates must be in YYYY-MM-DD format"}, status=400)

    sales_qs = Sale.objects.filter(shop=shop, date__date__range=[start_d, end_d])

    # --------------- SUMMARY REPORT ------------------
    if report_type == "summary":
        sums = sales_qs.aggregate(
            total_sales=Coalesce(Sum("total"), Decimal("0.00")),
            total_discount=Coalesce(Sum("discount"), Decimal("0.00")),
        )

        # Optional Profit Calculation
        profit_value = None
        try:
            # Calculate profit for summary: total sales - total discount - redeemed points - purchase costs
            total_redeemed_points = sales_qs.aggregate(
                total_points=Coalesce(Sum("redeemed_points"), 0)
            )["total_points"]
            
            # Get total purchase cost from sale items
            total_purchase_cost = SaleItem.objects.filter(
                sale__in=sales_qs
            ).aggregate(
                total_cost=Coalesce(
                    Sum(F('quantity') * F('product__purchased_price')),
                    Decimal('0.00')
                )
            )["total_cost"] or Decimal('0.00')
            
            profit_value = (
                (sums["total_sales"] or Decimal('0.00')) - 
                (sums["total_discount"] or Decimal('0.00')) - 
                Decimal(total_redeemed_points) - 
                total_purchase_cost
            )
        except Exception as e:
            print(f"Profit calculation error: {e}")
            profit_value = None

        payload = {
            "report_type": "summary",
            "start_date": start_date,
            "end_date": end_date,
            "summary": {
                "total_sales": float(sums["total_sales"]),
                "total_discount": float(sums["total_discount"]),
                "total_profit": float(profit_value) if profit_value is not None else None,
            },
            "total_invoices": sales_qs.count(),
        }

        if export == "excel":
            import pandas as pd
            from io import BytesIO

            df = pd.DataFrame([{
                "Start Date": start_date,
                "End Date": end_date,
                "Total Sales": payload["summary"]["total_sales"],
                "Total Discount": payload["summary"]["total_discount"],
                "Total Profit": payload["summary"]["total_profit"],
                "Invoices Count": payload["total_invoices"],
            }])

            buffer = BytesIO()
            df.to_excel(buffer, index=False)
            buffer.seek(0)

            resp = HttpResponse(
                buffer,
                content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            )
            resp["Content-Disposition"] = f'attachment; filename="sales_summary_{start_date}_to_{end_date}.xlsx"'
            return resp

        if export == "pdf":
            from io import BytesIO
            buffer = BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=A4)
            elements = []
            styles = getSampleStyleSheet()

            elements.append(Paragraph(f"Sales Summary Report ({start_date} - {end_date})", styles["Heading2"]))
            elements.append(Spacer(1, 12))

            table_data = [[
                "Total Sales", "Total Discount", "Total Profit", "Invoices Count"
            ], [
                f'{payload["summary"]["total_sales"]:.2f}',
                f'{payload["summary"]["total_discount"]:.2f}',
                "-" if payload["summary"]["total_profit"] is None else f'{payload["summary"]["total_profit"]:.2f}',
                str(payload["total_invoices"]),
            ]]

            table = Table(table_data)
            table.setStyle(TableStyle([
                ("BACKGROUND", (0, 0), (-1, 0), colors.grey),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                ("GRID", (0, 0), (-1, -1), 1, colors.black),
                ("ROWBACKGROUNDS", (0, 1), (-1, -1), [colors.whitesmoke, colors.beige]),
            ]))

            elements.append(table)
            doc.build(elements)
            buffer.seek(0)
            resp = HttpResponse(buffer, content_type="application/pdf")
            resp["Content-Disposition"] = f'attachment; filename="sales_summary_{start_date}_to_{end_date}.pdf"'
            return resp

        return Response(payload)

    # --------------- DETAIL REPORT ------------------
    else:
        try:
            # Fetch sales with related data for profit calculation
            sales_with_items = sales_qs.select_related("customer").prefetch_related(
                "items", "items__product"
            ).order_by("date", "id")

            def fmt_date(d):
                if d is None:
                    return ""
                if isinstance(d, _datetime):
                    return d.strftime("%Y-%m-%d %H:%M")
                if isinstance(d, _date):
                    return d.strftime("%Y-%m-%d")
                return str(d)

            # Process records with profit calculation
            records = []
            total_sales = Decimal('0.00')
            total_discount = Decimal('0.00')
            total_redeemed_points = 0
            total_profit = Decimal('0.00')

            for sale in sales_with_items:
                # Calculate profit for this sale
                sale_profit = Decimal('0.00')
                total_purchase_cost = Decimal('0.00')
                
                # Calculate total purchase cost for all items in this sale
                for item in sale.items.all():
                    # SaleItem has .quantity attribute (this is correct)
                    purchase_price = item.product.purchased_price if item.product.purchased_price else Decimal('0.00')
                    item_purchase_cost = purchase_price * item.quantity
                    total_purchase_cost += item_purchase_cost

                # Calculate profit: total - discount - redeemed points - purchase cost
                sale_profit = (
                    sale.total - 
                    sale.discount - 
                    Decimal(sale.redeemed_points) - 
                    total_purchase_cost
                )

                rec = {
                    "invoice_no": f"INV-{sale.id}",
                    "customer": sale.customer.name if sale.customer else "",
                    "date": fmt_date(sale.date),
                    "total": float(sale.total),
                    "discount": float(sale.discount),
                    "redeemed_points": sale.redeemed_points,
                    "profit": float(sale_profit),
                }
                
                records.append(rec)
                
                # Update totals
                total_sales += sale.total
                total_discount += sale.discount
                total_redeemed_points += sale.redeemed_points
                total_profit += sale_profit

            # Prepare payload
            payload = {
                "report_type": "detail",
                "start_date": start_date,
                "end_date": end_date,
                "records": records,
                "count": len(records),
                "totals": {
                    "total_sales": float(total_sales),
                    "total_discount": float(total_discount),
                    "total_redeemed_points": total_redeemed_points,
                    "total_profit": float(total_profit),
                },
            }

            # ----- Excel export -----
            if export == "excel":
                import pandas as pd
                from io import BytesIO

                # Create DataFrame from records
                df = pd.DataFrame(records)
                
                # Add totals row
                totals_row = {
                    "invoice_no": "TOTAL",
                    "customer": "",
                    "date": "",
                    "total": float(total_sales),
                    "discount": float(total_discount),
                    "redeemed_points": total_redeemed_points,
                    "profit": float(total_profit),
                }
                
                df = pd.concat([df, pd.DataFrame([totals_row])], ignore_index=True)
                
                buffer = BytesIO()
                df.to_excel(buffer, index=False)
                buffer.seek(0)

                resp = HttpResponse(
                    buffer,
                    content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )
                resp["Content-Disposition"] = f'attachment; filename="sales_detail_{start_date}_to_{end_date}.xlsx"'
                return resp

            # ----- PDF export -----
            if export == "pdf":
                from io import BytesIO

                buffer = BytesIO()
                doc = SimpleDocTemplate(buffer, pagesize=A4)
                elements = []
                styles = getSampleStyleSheet()

                elements.append(
                    Paragraph(
                        f"Sales Detail Report ({start_date} - {end_date})",
                        styles["Heading2"],
                    )
                )
                elements.append(Spacer(1, 12))

                # Prepare table headers
                headers = ["Invoice No", "Customer", "Date", "Total", "Discount", "Redeemed Points", "Profit"]

                table_data = [headers]
                
                # Add data rows
                for r in records:
                    row = [
                        r["invoice_no"],
                        r["customer"],
                        r["date"],
                        f'{r["total"]:.2f}',
                        f'{r["discount"]:.2f}',
                        str(r["redeemed_points"]),
                        f'{r["profit"]:.2f}',
                    ]
                    table_data.append(row)
                
                # Add totals row
                totals_row = [
                    "TOTAL",
                    "",
                    "",
                    f'{float(total_sales):.2f}',
                    f'{float(total_discount):.2f}',
                    str(total_redeemed_points),
                    f'{float(total_profit):.2f}',
                ]
                table_data.append(totals_row)

                # Create and style table
                table = Table(table_data, repeatRows=1)
                table.setStyle(
                    TableStyle(
                        [
                            ("BACKGROUND", (0, 0), (-1, 0), colors.grey),
                            ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                            ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                            ("GRID", (0, 0), (-1, -1), 1, colors.black),
                            ("BACKGROUND", (0, -1), (-1, -1), colors.lightgrey),
                            ("FONTWEIGHT", (0, -1), (-1, -1), "BOLD"),
                        ]
                    )
                )
                elements.append(table)
                doc.build(elements)
                buffer.seek(0)

                resp = HttpResponse(buffer, content_type="application/pdf")
                resp["Content-Disposition"] = f'attachment; filename="sales_detail_{start_date}_to_{end_date}.pdf"'
                return resp

            return Response(payload)

        except Exception as e:
            return Response({"error": f"detail report failed: {type(e).__name__}: {e}"}, status=400)


# -----------------------------
# Business Overview Views
# -----------------------------
class BusinessOverviewAPIView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None

        sales_filter = {"shop": shop}
        expenses_filter = {"shop": shop}
        purchases_filter = {"shop": shop}

        if start_date and end_date:
            sales_filter["date__date__range"] = [start_date, end_date]
            expenses_filter["date__range"] = [start_date, end_date]
            purchases_filter["date__range"] = [start_date, end_date]

        # Totals
        total_income = (
            Sale.objects.filter(**sales_filter)
            .aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))
            ["total"]
        )
        
        # VAT metrics
        total_vat = (
            Sale.objects.filter(**sales_filter)
            .aggregate(vat=Coalesce(Sum("vat_amount"), Decimal("0.00")))
            ["vat"]
        )
        base_sales_amount = (
            Sale.objects.filter(**sales_filter)
            .aggregate(subtotal=Coalesce(Sum("subtotal"), Decimal("0.00")))
            ["subtotal"]
        )
        
        total_expense = (
            Expense.objects.filter(**expenses_filter)
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))
            ["total"]
        )
        total_purchase = (
            Purchase.objects.filter(**purchases_filter)
            .aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))
            ["total"]
        )

        # Calculate purchased price of sold products (cost of goods sold)
        sale_items_filter = {"sale__shop": shop}
        if start_date and end_date:
            sale_items_filter["sale__date__date__range"] = [start_date, end_date]
        
        cost_of_goods_sold_expr = ExpressionWrapper(
            F("quantity") * F("product__purchased_price"),
            output_field=DecimalField(max_digits=14, decimal_places=2),
        )
        cost_of_goods_sold = (
            SaleItem.objects.filter(**sale_items_filter)
            .aggregate(total=Coalesce(Sum(cost_of_goods_sold_expr), Decimal("0.00")))
            ["total"]
        )
        
        # Profits
        # Gross Profit = Sales Revenue - Purchased price of selling product (COGS)
        gross_profit = total_income - cost_of_goods_sold
        # Net Profit = Gross Profit - Expense
        net_profit = gross_profit - total_expense

        # Inventory value
        stock_value_expr = ExpressionWrapper(
            F("stock") * F("purchased_price"),
            output_field=DecimalField(max_digits=14, decimal_places=2),
        )
        total_stock_value = (
            Product.objects.filter(shop=shop).aggregate(
                total=Coalesce(Sum(stock_value_expr), Decimal("0.00"))
            )["total"]
            or Decimal("0.00")
        )

        # Fixed costs
        fixed_cost = (
            Expense.objects.filter(**expenses_filter)
            .filter(category__icontains="rent")
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
        ) + (
            Expense.objects.filter(**expenses_filter)
            .filter(category__icontains="salary")
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
        )

        # Cash flow & growth
        cash_flow = total_income - total_expense
        business_growth = (
            (gross_profit / total_purchase * 100)
            if total_purchase and total_purchase > 0
            else Decimal("0.00")
        )

        # Capital investment
        capital_investment = total_purchase

        return Response(
            {
                "total_income": float(total_income),
                "total_vat_amount": float(total_vat),
                "base_sales_amount": float(base_sales_amount),
                "total_expense": float(total_expense),
                "total_purchase": float(total_purchase),
                "gross_profit": float(gross_profit),
                "net_profit": float(net_profit),
                "fixed_cost": float(fixed_cost),
                "cash_flow": float(cash_flow),
                "business_growth": float(business_growth),
                "total_stock_value": float(total_stock_value),
                "capital_investment": float(capital_investment),
            }
        )


class BusinessOverviewTimeseriesAPIView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None

        sales_filter = {"shop": shop}
        expenses_filter = {"shop": shop}
        purchases_filter = {"shop": shop}

        if start_date and end_date:
            sales_filter["date__date__range"] = [start_date, end_date]
            expenses_filter["date__range"] = [start_date, end_date]
            purchases_filter["date__range"] = [start_date, end_date]

        sales = (
            Sale.objects.filter(**sales_filter)
            .annotate(d=TruncDate("date"))
            .values("d")
            .annotate(total=Sum("total"))
            .order_by("d")
        )
        expenses = (
            Expense.objects.filter(**expenses_filter)
            .annotate(d=TruncDate("date"))
            .values("d")
            .annotate(total=Sum("amount"))
            .order_by("d")
        )
        purchases = (
            Purchase.objects.filter(**purchases_filter)
            .annotate(d=TruncDate("date"))
            .values("d")
            .annotate(total=Sum("total"))
            .order_by("d")
        )

        all_dates = sorted(
            {*[s["d"] for s in sales], *[e["d"] for e in expenses], *[p["d"] for p in purchases]}
        )
        sales_map = {x["d"]: x["total"] or 0 for x in sales}
        exp_map = {x["d"]: x["total"] or 0 for x in expenses}
        pur_map = {x["d"]: x["total"] or 0 for x in purchases}

        labels = [d.isoformat() for d in all_dates]
        income = [float(sales_map.get(d, 0)) for d in all_dates]
        expense = [float(exp_map.get(d, 0)) for d in all_dates]
        purchase = [float(pur_map.get(d, 0)) for d in all_dates]
        cash_flow = [i - e for i, e in zip(income, expense)]
        net_profit = [i - e - p for i, e, p in zip(income, expense, purchase)]

        return Response(
            {
                "labels": labels,
                "income": income,
                "expense": expense,
                "purchase": purchase,
                "cash_flow": cash_flow,
                "net_profit": net_profit,
            }
        )


class BusinessOverviewExportPDF(ShopFilterMixin, APIView):
    authentication_classes = [JWTAuthentication] 
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    def get(self, request):
        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # Get summary data
        sales_filter = {"shop": shop}
        expenses_filter = {"shop": shop}
        purchases_filter = {"shop": shop}

        if start_date and end_date:
            sales_filter["date__date__range"] = [start_date, end_date]
            expenses_filter["date__range"] = [start_date, end_date]
            purchases_filter["date__range"] = [start_date, end_date]

        total_income = (
            Sale.objects.filter(**sales_filter)
            .aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))
            ["total"]
        )
        total_expense = (
            Expense.objects.filter(**expenses_filter)
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))
            ["total"]
        )
        total_purchase = (
            Purchase.objects.filter(**purchases_filter)
            .aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))
            ["total"]
        )

        # Calculate purchased price of sold products (cost of goods sold)
        sale_items_filter = {"sale__shop": shop}
        if start_date and end_date:
            sale_items_filter["sale__date__date__range"] = [start_date, end_date]
        
        cost_of_goods_sold_expr = ExpressionWrapper(
            F("quantity") * F("product__purchased_price"),
            output_field=DecimalField(max_digits=14, decimal_places=2),
        )
        cost_of_goods_sold = (
            SaleItem.objects.filter(**sale_items_filter)
            .aggregate(total=Coalesce(Sum(cost_of_goods_sold_expr), Decimal("0.00")))
            ["total"]
        )
        
        # Profits
        # Gross Profit = Sales Revenue - Purchased price of selling product (COGS)
        gross_profit = total_income - cost_of_goods_sold
        # Net Profit = Gross Profit - Expense
        net_profit = gross_profit - total_expense

        # Inventory value
        stock_value_expr = ExpressionWrapper(
            F("stock") * F("purchased_price"),
            output_field=DecimalField(max_digits=14, decimal_places=2),
        )
        total_stock_value = (
            Product.objects.filter(shop=shop).aggregate(
                total=Coalesce(Sum(stock_value_expr), Decimal("0.00"))
            )["total"]
            or Decimal("0.00")
        )

        # Fixed costs
        fixed_cost = (
            Expense.objects.filter(**expenses_filter)
            .filter(category__icontains="rent")
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
        ) + (
            Expense.objects.filter(**expenses_filter)
            .filter(category__icontains="salary")
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
        )

        # Cash flow & growth
        cash_flow = total_income - total_expense
        business_growth = (
            (gross_profit / total_purchase * 100)
            if total_purchase and total_purchase > 0
            else Decimal("0.00")
        )

        # Capital investment
        capital_investment = total_purchase

        summary = {
            "total_income": float(total_income),
            "total_expense": float(total_expense),
            "total_purchase": float(total_purchase),
            "gross_profit": float(gross_profit),
            "net_profit": float(net_profit),
            "fixed_cost": float(fixed_cost),
            "cash_flow": float(cash_flow),
            "total_stock_value": float(total_stock_value),
            "capital_investment": float(capital_investment),
            "business_growth": float(business_growth),
        }

        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []

        story.append(Paragraph("Business Overview Report", styles["Title"]))
        story.append(Paragraph(f"Shop: {shop.shop_name if shop else 'Unknown'}", styles["Normal"]))
        if start_date and end_date:
            story.append(Paragraph(f"Period: {start_date} to {end_date}", styles["Normal"]))
        story.append(Spacer(1, 12))

        table_data = [
            ["Metric", "Amount"],
            ["Total Income", f'{summary["total_income"]:.2f}'],
            ["Total Expense", f'{summary["total_expense"]:.2f}'],
            ["Total Purchase", f'{summary["total_purchase"]:.2f}'],
            ["Gross Profit", f'{summary["gross_profit"]:.2f}'],
            ["Net Profit", f'{summary["net_profit"]:.2f}'],
            ["Fixed Cost", f'{summary["fixed_cost"]:.2f}'],
            ["Cash Flow", f'{summary["cash_flow"]:.2f}'],
            ["Inventory Value", f'{summary["total_stock_value"]:.2f}'],
            ["Capital Investment", f'{summary["capital_investment"]:.2f}'],
            ["Business Growth %", f'{summary["business_growth"]:.2f}%'],
        ]

        t = Table(table_data, colWidths=[220, 220])
        t.setStyle(
            TableStyle(
                [
                    ("BACKGROUND", (0, 0), (-1, 0), colors.lightgrey),
                    ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
                    ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                    ("ALIGN", (1, 1), (-1, -1), "RIGHT"),
                ]
            )
        )
        story.append(t)
        doc.build(story)

        buffer.seek(0)
        response = HttpResponse(buffer, content_type="application/pdf")
        response["Content-Disposition"] = (
            f'attachment; filename="business_overview_{start_date}_{end_date}.pdf"'
        )
        return response


class BusinessOverviewExportExcel(ShopFilterMixin, APIView):
    authentication_classes = [JWTAuthentication]
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # Get summary data
        sales_filter = {"shop": shop}
        expenses_filter = {"shop": shop}
        purchases_filter = {"shop": shop}

        if start_date and end_date:
            sales_filter["date__date__range"] = [start_date, end_date]
            expenses_filter["date__range"] = [start_date, end_date]
            purchases_filter["date__range"] = [start_date, end_date]

        total_income = (
            Sale.objects.filter(**sales_filter)
            .aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))
            ["total"]
        )
        total_expense = (
            Expense.objects.filter(**expenses_filter)
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))
            ["total"]
        )
        total_purchase = (
            Purchase.objects.filter(**purchases_filter)
            .aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))
            ["total"]
        )

        # Calculate purchased price of sold products (cost of goods sold)
        sale_items_filter = {"sale__shop": shop}
        if start_date and end_date:
            sale_items_filter["sale__date__date__range"] = [start_date, end_date]
        
        cost_of_goods_sold_expr = ExpressionWrapper(
            F("quantity") * F("product__purchased_price"),
            output_field=DecimalField(max_digits=14, decimal_places=2),
        )
        cost_of_goods_sold = (
            SaleItem.objects.filter(**sale_items_filter)
            .aggregate(total=Coalesce(Sum(cost_of_goods_sold_expr), Decimal("0.00")))
            ["total"]
        )
        
        # Profits
        # Gross Profit = Sales Revenue - Purchased price of selling product (COGS)
        gross_profit = total_income - cost_of_goods_sold
        # Net Profit = Gross Profit - Expense
        net_profit = gross_profit - total_expense

        # Inventory value
        stock_value_expr = ExpressionWrapper(
            F("stock") * F("purchased_price"),
            output_field=DecimalField(max_digits=14, decimal_places=2),
        )
        total_stock_value = (
            Product.objects.filter(shop=shop).aggregate(
                total=Coalesce(Sum(stock_value_expr), Decimal("0.00"))
            )["total"]
            or Decimal("0.00")
        )

        # Fixed costs
        fixed_cost = (
            Expense.objects.filter(**expenses_filter)
            .filter(category__icontains="rent")
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
        ) + (
            Expense.objects.filter(**expenses_filter)
            .filter(category__icontains="salary")
            .aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
        )

        # Cash flow & growth
        cash_flow = total_income - total_expense
        business_growth = (
            (gross_profit / total_purchase * 100)
            if total_purchase and total_purchase > 0
            else Decimal("0.00")
        )

        # Capital investment
        capital_investment = total_purchase

        summary = {
            "total_income": float(total_income),
            "total_expense": float(total_expense),
            "total_purchase": float(total_purchase),
            "gross_profit": float(gross_profit),
            "net_profit": float(net_profit),
            "fixed_cost": float(fixed_cost),
            "cash_flow": float(cash_flow),
            "total_stock_value": float(total_stock_value),
            "capital_investment": float(capital_investment),
            "business_growth": float(business_growth),
        }

        wb = Workbook()
        ws = wb.active
        ws.title = "Business Overview"
        ws.append(["Business Overview Report"])
        ws.append([f"Shop: {shop.shop_name if shop else 'Unknown'}"])
        if start_date and end_date:
            ws.append([f"Period: {start_date} to {end_date}"])
        ws.append([])
        ws.append(["Metric", "Amount"])

        for k, v in [
            ("Total Income", summary["total_income"]),
            ("Total Expense", summary["total_expense"]),
            ("Total Purchase", summary["total_purchase"]),
            ("Gross Profit", summary["gross_profit"]),
            ("Net Profit", summary["net_profit"]),
            ("Fixed Cost", summary["fixed_cost"]),
            ("Cash Flow", summary["cash_flow"]),
            ("Inventory Value", summary["total_stock_value"]),
            ("Capital Investment", summary["capital_investment"]),
            ("Business Growth %", summary["business_growth"]),
        ]:
            ws.append([k, v])

        stream = io.BytesIO()
        wb.save(stream)
        stream.seek(0)
        response = HttpResponse(
            stream.getvalue(),
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )
        response["Content-Disposition"] = (
            f'attachment; filename="business_overview_{start_date}_{end_date}.xlsx"'
        )
        return response


# -----------------------------
# JWT Authentication Views
# -----------------------------
from rest_framework_simplejwt.exceptions import AuthenticationFailed
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer

class LoginView(APIView):
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        print("=== LOGIN ATTEMPT ===")
        print("Username:", request.data.get('username'))
        
        username = request.data.get('username')
        password = request.data.get('password')
        
        if not username or not password:
            return Response({
                "detail": "Username and password are required."
            }, status=400)
        
        # First, try to authenticate the user
        from django.contrib.auth import authenticate
        user = authenticate(username=username, password=password)
        
        if user is None:
            print("Authentication failed - invalid credentials")
            return Response({
                "detail": "Invalid username or password."
            }, status=400)
        
        print(f"✓ User authenticated: {user.username}")
        
        # Check if user has profile and shop
        if not hasattr(user, 'profile'):
            print("✗ User has no profile")
            return Response({
                "detail": "User profile not found. Please contact support."
            }, status=400)
        
        if not hasattr(user.profile, 'shop'):
            print("✗ User profile has no shop")
            return Response({
                "detail": "Shop not found for user."
            }, status=400)
        
        shop = user.profile.shop
        print(f"✓ User's shop: {shop.shop_name} (ID: {shop.shop_id})")
        
        # IMPORTANT: Check if payment was verified but shop not activated
        if hasattr(shop, 'payment_request'):
            pr = shop.payment_request
            print(f"Payment request found: Verified={pr.is_verified}")
            
            if pr.is_verified and not shop.is_active:
                print(f"⚠️ Payment verified but shop not active. Activating now...")
                if shop.plan == "monthly":
                    shop.activate_monthly()
                elif shop.plan == "yearly":
                    shop.activate_yearly()
                else:
                    shop.is_active = True
                    shop.save()
                print(f"✓ Shop activated after payment verification: {shop.is_active}")
        
        # Check if trial expired
        if shop.plan == "trial" and shop.expire_date and shop.expire_date < date.today():
            print("✗ Trial expired")
            shop.is_active = False
            shop.save()
        
        # Check if shop is active
        if not shop.is_active:
            print("✗ Shop is not active")
            
            # Check if there's a pending payment request
            if hasattr(shop, 'payment_request'):
                pr = shop.payment_request
                if pr.is_verified:
                    response_data = {
                        "detail": "Payment verified but activation pending. Please try logging in again.",
                        "shop_id": shop.shop_id,
                        "plan": shop.plan,
                        "payment_verified": True,
                        "is_active": False,
                        "error_code": "ACTIVATION_PENDING"
                    }
                else:
                    response_data = {
                        "detail": "Payment pending verification. Please wait for admin approval.",
                        "shop_id": shop.shop_id,
                        "plan": shop.plan,
                        "is_active": False,
                        "payment_submitted": True,
                        "error_code": "PAYMENT_PENDING"
                    }
            else:
                response_data = {
                    "detail": "Your subscription is inactive. Please make payment to activate.",
                    "shop_id": shop.shop_id,
                    "plan": shop.plan,
                    "is_active": False,
                    "expire_date": str(shop.expire_date) if shop.expire_date else None,
                    "requires_payment": shop.plan in ["monthly", "yearly"],
                    "error_code": "SUBSCRIPTION_INACTIVE"
                }
                
                if shop.plan == "trial":
                    response_data["detail"] = "Your trial has expired. Please upgrade to continue."
                    response_data["error_code"] = "TRIAL_EXPIRED"
            
            return Response(response_data, status=402)
        
        print("✓ Shop is active, generating tokens")
        
        # Generate JWT tokens manually
        from rest_framework_simplejwt.tokens import RefreshToken
        refresh = RefreshToken.for_user(user)
        
        response_data = {
            "access": str(refresh.access_token),
            "refresh": str(refresh),
            "user": {
                "id": user.id,
                "username": user.username,
                "email": user.email if user.email else ""
            },
            "shop": {
                "shop_id": shop.shop_id,
                "shop_name": shop.shop_name,
                "plan": shop.plan,
                "is_active": shop.is_active,
                "expire_date": str(shop.expire_date) if shop.expire_date else None,
                "logo_url": shop.logo.url if shop.logo else None
            }
        }
        
        print("✓ Login successful")
        return Response(response_data, status=200)
    
# Shop Registration & Subscription
# -----------------------------
class ShopRegistrationView(APIView):
    permission_classes = [permissions.AllowAny]

    def post(self, request):
        serializer = ShopRegistrationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.validated_data

        # Create Shop
        shop = Shop.objects.create(
            shop_name=data["shop_name"],
            location=data.get("location", ""),
            phone=data["phone"],
            email_or_link=data.get("email_or_link", ""),
            owner_name=data["owner_name"],
            logo=request.FILES.get("logo"),
            plan=data["subscription_plan"],
            is_active=False
        )

        # Activate trial instantly
        if data["subscription_plan"] == "trial":
            shop.activate_trial()
            message = "🎉 Trial activated! You can login now."
        else:
            message = "✅ Registration successful! Please complete payment verification."

        # Create User
        User = get_user_model()
        user = User.objects.create_user(
            username=data["username"],
            password=data["password"]
        )

        UserProfile.objects.create(
            user=user,
            shop=shop,
            role="admin",  # Shop creator is admin
            is_owner=True,  # Shop creator is the owner
            profile_picture=None
        )

        response = {
            "success": True,
            "message": message,
            "shop_id": shop.shop_id,
            "logo": shop.logo.url if shop.logo else None,
            "plan": shop.plan,
            "is_active": shop.is_active,
            "expire_date": shop.expire_date,
            "requires_payment": shop.plan in ["monthly", "yearly"],
            "phone": shop.phone
        }

        # If paid plan, show payment instructions
        if shop.plan in ["monthly", "yearly"]:
            response["payment_instructions"] = {
                "message": "Please send payment and submit verification",
                "bkash": "01791927084",
                "nagad": "01791927084",
                "amount": 750 if shop.plan == "monthly" else 7990,
                "note": "After payment, submit the last 4 digits of sender number."
            }

        return Response(response, status=201)

# Update the CreatePaymentRequestView in views.py:
class CreatePaymentRequestView(CreateAPIView):
    serializer_class = PaymentRequestSerializer
    permission_classes = [permissions.AllowAny]

    def create(self, request, *args, **kwargs):
        print("=== PAYMENT REQUEST RECEIVED ===")
        print("Request data:", request.data)
        print("Files:", request.FILES)
        
        shop_id = request.data.get("shop_id")
        print(f"Shop ID: {shop_id}")
        
        try:
            shop = Shop.objects.get(shop_id=shop_id)
            print(f"Shop found: {shop.shop_name}, Plan: {shop.plan}")
        except Shop.DoesNotExist:
            print(f"Shop not found: {shop_id}")
            return Response({"detail": "Shop not found."}, status=404)

        # Prevent duplicate verified requests
        existing = getattr(shop, "payment_request", None)
        if existing:
            print(f"Existing payment request found: {existing.id}, Verified: {existing.is_verified}")
            if existing.is_verified:
                return Response({"detail": "Payment already verified."}, status=400)
            existing.delete()  # remove old unverified request
            print("Old unverified request deleted")
        
        # Get amount from request (it comes as string from FormData)
        submitted_amount_str = request.data.get("amount", "0")
        try:
            submitted_amount = int(submitted_amount_str)
        except ValueError:
            submitted_amount = 0
            
        print(f"Submitted amount: {submitted_amount} (as string: '{submitted_amount_str}')")
        
        # Calculate expected amount based on plan
        if shop.plan == "monthly":
            expected_amount = 750
        elif shop.plan == "yearly":
            expected_amount = 7990
        else:
            expected_amount = 0
            
        print(f"Expected amount for {shop.plan} plan: {expected_amount}")
        
        if submitted_amount != expected_amount:
            return Response({
                "detail": f"Invalid amount. Expected {expected_amount} tk for {shop.plan} plan, got {submitted_amount} tk."
            }, status=400)

        # Prepare data for serializer
        payment_data = {
            "method": request.data.get("method"),
            "sender_last4": request.data.get("sender_last4"),
            "amount": submitted_amount,
            "transaction_id": request.data.get("transaction_id", ""),
        }
        
        print("Payment data for serializer:", payment_data)
        
        # Handle file if present
        if request.FILES.get("screenshot"):
            payment_data["screenshot"] = request.FILES["screenshot"]
            print("Screenshot file received")
        
        serializer = self.get_serializer(data=payment_data)
        
        if serializer.is_valid():
            print("Serializer is valid")
            payment_request = serializer.save(shop=shop)
            print(f"Payment request created: {payment_request.id}")
            
            return Response({
                "detail": "Payment request submitted successfully.",
                "shop_id": shop.shop_id,
                "payment_id": payment_request.id,
                "status": "pending",
                "message": "Your payment details have been received. Admin will verify and activate your shop shortly."
            }, status=201)
        else:
            print("Serializer errors:", serializer.errors)
            return Response({
                "detail": "Invalid payment data.",
                "errors": serializer.errors
            }, status=400)


class AdminVerifyPaymentView(APIView):
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, shop_id):
        try:
            shop = Shop.objects.get(shop_id=shop_id)
        except Shop.DoesNotExist:
            return Response({"detail": "Shop not found."}, status=404)

        # Check if payment request exists
        if not hasattr(shop, "payment_request"):
            return Response({"detail": "No payment request found for this shop."}, status=404)

        pr = shop.payment_request

        if pr.is_verified:
            return Response({"detail": "Payment already verified."}, status=400)

        # Mark as verified
        pr.is_verified = True
        pr.verified_at = timezone.now()
        pr.verified_by = request.user
        pr.save()

        # Calculate new expiry date with remaining days
        today = date.today()
        
        # If subscription is still active and has remaining days, add to those days
        if shop.expire_date and shop.expire_date > today:
            # Add to remaining days
            base_date = shop.expire_date
        else:
            # Start from today if expired
            base_date = today
        
        # Add the new subscription period based on payment request plan
        plan = pr.plan
        if plan == 'monthly':
            new_expire_date = base_date + timedelta(days=30)
        elif plan == 'yearly':
            new_expire_date = base_date + timedelta(days=365)
        elif plan == 'trial':
            new_expire_date = base_date + timedelta(days=7)
        else:
            # Fallback to shop.plan if pr.plan is not set
            if shop.plan == "monthly":
                new_expire_date = base_date + timedelta(days=30)
            elif shop.plan == "yearly":
                new_expire_date = base_date + timedelta(days=365)
            else:
                new_expire_date = base_date + timedelta(days=7)
        
        # Update shop
        shop.plan = plan if plan else shop.plan
        shop.expire_date = new_expire_date
        shop.is_active = True
        shop.save()

        # Send SMS notification (implement your SMS service)
        self.send_activation_notification(shop)

        return Response({
            "detail": f"Payment verified and subscription activated successfully. Subscription extended to {new_expire_date.strftime('%B %d, %Y')}.",
            "shop": {
                "shop_id": shop.shop_id,
                "shop_name": shop.shop_name,
                "plan": shop.plan,
                "is_active": shop.is_active,
                "expire_date": new_expire_date.isoformat(),
                "activated_at": timezone.now().isoformat()
            }
        })
    
class PaymentVerificationStatusView(APIView):
    permission_classes = [permissions.AllowAny]
    
    def get(self, request):
        shop_id = request.query_params.get('shop_id')
        if not shop_id:
            return Response({"detail": "Shop ID is required"}, status=400)
        
        try:
            shop = Shop.objects.get(shop_id=shop_id)
            
            response_data = {
                "shop_id": shop.shop_id,
                "shop_name": shop.shop_name,
                "plan": shop.plan,
                "is_active": shop.is_active,
                "expire_date": shop.expire_date,
                "status": "active" if shop.is_active else "inactive"
            }
            
            # Add payment request info if exists
            if hasattr(shop, "payment_request"):
                pr = shop.payment_request
                response_data["payment_request"] = {
                    "method": pr.method,
                    "amount": pr.amount,
                    "is_verified": pr.is_verified,
                    "created_at": pr.created_at,
                    "verified_at": pr.verified_at if pr.is_verified else None
                }
                response_data["status"] = "verified" if pr.is_verified else "pending_verification"
            
            return Response(response_data)
            
        except Shop.DoesNotExist:
            return Response({"detail": "Shop not found"}, status=404)
    
    def send_activation_notification(self, shop):
        """Send activation notification to shop owner"""
        # Implement SMS/email notification here
        print(f"Shop {shop.shop_name} ({shop.shop_id}) activated!")
        print(f"Phone: {shop.phone}")
        print(f"Plan: {shop.plan}, Expires: {shop.expire_date}")
    
    def send_activation_sms(self, shop):
        """Send activation SMS to shop owner"""
        # Implement SMS sending here (Twilio, SMS API, etc.)
        message = f"Your shop {shop.shop_name} has been activated! Login at https://yourdomain.com"
        print(f"SMS to {shop.phone}: {message}")
        # Actual SMS sending code would go here

class SubscriptionRequiredView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        profile = getattr(request.user, 'profile', None)
        if not profile:
            return Response({"detail": "User profile not found"}, status=400)
        
        shop = profile.shop
        return Response({
            "detail": "Subscription required to access this feature.",
            "shop_id": shop.shop_id,
            "shop_name": shop.shop_name,
            "plan": shop.plan,
            "is_active": shop.is_active,
            "expire_date": str(shop.expire_date) if shop.expire_date else None,
            "requires_payment": shop.plan in ["monthly", "yearly"] and not shop.is_active,
            "error_code": "SUBSCRIPTION_REQUIRED"
        }, status=402)


class SubscriptionStatusView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        shop = request.user.profile.shop
        
        # Calculate subscription status
        today = date.today()
        
        if shop.expire_date:
            days_remaining = (shop.expire_date - today).days
            if days_remaining < 0:
                status = "expired"
            elif days_remaining <= 7:
                status = "expiring_soon"
            else:
                status = "active"
        else:
            days_remaining = 0
            status = "unknown"
        
        # Determine monthly price based on plan
        monthly_price = 0
        if shop.plan == "monthly":
            monthly_price = 750
        elif shop.plan == "yearly":
            monthly_price = 666  # 7990/12 rounded
        
        # Calculate start date (expire_date - plan duration)
        start_date = None
        if shop.expire_date:
            if shop.plan == "trial":
                start_date = shop.expire_date - timedelta(days=7)
            elif shop.plan == "monthly":
                start_date = shop.expire_date - timedelta(days=30)
            elif shop.plan == "yearly":
                start_date = shop.expire_date - timedelta(days=365)

        data = {
            "shop_id": shop.shop_id,
            "shop_name": shop.shop_name,
            "logo": shop.logo.url if shop.logo else None,
            "plan": shop.plan,
            "is_active": shop.is_active,
            "expire_date": shop.expire_date.isoformat() if shop.expire_date else None,
            "start_date": start_date.isoformat() if start_date else None,
            "status": status,
            "days_remaining": days_remaining if days_remaining > 0 else 0,
            "monthly_price": monthly_price
        }

        return Response(data)


class RenewSubscriptionView(APIView):
    """Shop owner creates a payment request for renewal - does NOT automatically renew"""
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        try:
            shop = request.user.profile.shop
        except AttributeError:
            return Response({"detail": "User profile or shop not found."}, status=400)
        
        plan = request.data.get('plan')
        
        if plan not in ['monthly', 'yearly']:
            return Response({"detail": "Invalid plan. Choose 'monthly' or 'yearly'."}, status=400)
        
        # Check if there's already a pending payment request
        existing_request = PaymentRequest.objects.filter(shop=shop, is_verified=False).first()
        if existing_request:
            return Response({
                "detail": "You already have a pending payment request. Please wait for admin verification."
            }, status=400)
        
        # Determine the amount
        amount = 750 if plan == 'monthly' else 7990
        
        # Create payment request (admin will verify and then extend subscription)
        payment_request = PaymentRequest.objects.create(
            shop=shop,
            plan=plan,
            amount=amount,
            is_verified=False
        )
        
        return Response({
            "message": f"Payment request created for {plan} plan (৳{amount}). Please make the payment and wait for admin verification.",
            "payment_request_id": payment_request.id,
            "plan": plan,
            "amount": amount,
            "note": "Your subscription will be extended after payment verification. Your remaining days will be added to the new period."
        })


class UpdateShopLogoView(APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def post(self, request):
        shop = request.user.profile.shop

        new_logo = request.FILES.get("logo")
        if not new_logo:
            return Response({"detail": "Logo file required."}, status=400)

        shop.logo = new_logo
        shop.save()

        return Response({
            "detail": "Shop logo updated successfully.",
            "logo_url": shop.logo.url
        })


class UpdateProfilePictureView(APIView):
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def post(self, request):
        profile = request.user.profile
        pp = request.FILES.get("profile_picture")

        if not pp:
            return Response({"detail": "Profile picture required."}, status=400)

        profile.profile_picture = pp
        profile.save()

        return Response({
            "detail": "Profile picture updated.",
            "profile_picture_url": profile.profile_picture.url
        })

class ShopUserViewSet(viewsets.ModelViewSet):

    required_feature = "user_management"
    queryset = UserProfile.objects.select_related('user', 'shop')
    serializer_class = UserProfileSerializer
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get_permissions(self):
        """
        Only allow shop owners to manage shop users
        """
        # Check if user is owner for write operations
        if self.action in ['create', 'update', 'partial_update', 'destroy']:
            profile = self.request.user.profile
            if not profile.is_owner:
                raise PermissionDenied("Only the shop owner can create/update/delete users")
        return super().get_permissions()
    
    def get_queryset(self):
        """Return only users from current user's shop"""
        shop = self.request.user.profile.shop
        return UserProfile.objects.filter(shop=shop).order_by('-id')
    
    def list(self, request, *args, **kwargs):
        """List users with current user marked"""
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        
        # Return just the users list (frontend expects .results or direct array)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """Create new shop user"""
        try:
            phone = request.data.get('phone')
            username = request.data.get('username', phone)  # Use phone as username if not provided
            email = request.data.get('email', '')
            password = request.data.get('password')
            role = request.data.get('role', 'seller')
            
            # Get permission flags
            can_manage_products = request.data.get('can_manage_products', False)
            can_manage_sales = request.data.get('can_manage_sales', False)
            can_manage_purchases = request.data.get('can_manage_purchases', False)
            can_view_reports = request.data.get('can_view_reports', False)
            
            print(f"Creating user with phone: {phone}, role: {role}")
            
            # Validate required fields
            if not all([phone, password]):
                return Response({
                    "detail": "Phone and password are required"
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Validate role
            valid_roles = ['admin', 'manager', 'seller', 'cashier']
            if role not in valid_roles:
                return Response({
                    "detail": f"Invalid role. Choose from: {', '.join(valid_roles)}"
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Check if username already exists
            if User.objects.filter(username=phone).exists():
                return Response({
                    "detail": "Phone number already exists"
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Create user
            user = User.objects.create_user(
                username=phone,
                email=email if email else '',
                password=password
            )
            
            print(f"User created: {user.username}")
            
            # Create profile with permissions
            profile = UserProfile.objects.create(
                user=user,
                shop=request.user.profile.shop,
                role=role,
                is_owner=False,
                can_manage_products=can_manage_products,
                can_manage_sales=can_manage_sales,
                can_manage_purchases=can_manage_purchases,
                can_view_reports=can_view_reports
            )
            
            print(f"Profile created: {profile.id}, role: {profile.role}")
            
            # Refresh the user to ensure profile relation is loaded
            user.refresh_from_db()
            profile.refresh_from_db()
            
            serializer = self.get_serializer(profile)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            print(f"Error creating user: {str(e)}")
            import traceback
            traceback.print_exc()
            return Response({
                "detail": f"Error creating user: {str(e)}"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, *args, **kwargs):
        """Update user (role changes, etc.)"""
        instance = self.get_object()

        # Never allow editing the owner profile
        if instance.is_owner:
            return Response({"detail": "Cannot modify the shop owner user."}, status=status.HTTP_403_FORBIDDEN)
        # Never allow changing your own role (prevents lockout)       
        if instance.user == request.user and "role" in request.data:           
            return Response({"detail": "Cannot change your own role."}, status=status.HTTP_400_BAD_REQUEST)
        
        # Prevent updating owner status
        if 'is_owner' in request.data:
            return Response({
                "detail": "Cannot change owner status"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Allow updating role, permissions, username, and is_active
        # Note: phone is read-only but we accept it in the request to avoid errors
        allowed_keys = {
            "role", "username", "phone", "email", "can_manage_products", "can_manage_sales",
            "can_manage_purchases", "can_view_reports", "is_active"
        }
        bad_keys = set(request.data.keys()) - allowed_keys
        if bad_keys:
            return Response({"detail": f"Unsupported fields: {', '.join(sorted(bad_keys))}"},
                            status=status.HTTP_400_BAD_REQUEST)

        if "role" in request.data:
            role = request.data.get("role")
            if role == "cashier":
                role = "seller"
            if role not in {"seller", "manager"}:
                return Response({"detail": "Role must be seller or manager."},
                                status=status.HTTP_400_BAD_REQUEST)
            instance.role = role

        # Update permissions
        if "can_manage_products" in request.data:
            instance.can_manage_products = request.data.get("can_manage_products")
        if "can_manage_sales" in request.data:
            instance.can_manage_sales = request.data.get("can_manage_sales")
        if "can_manage_purchases" in request.data:
            instance.can_manage_purchases = request.data.get("can_manage_purchases")
        if "can_view_reports" in request.data:
            instance.can_view_reports = request.data.get("can_view_reports")
        
        # Update username
        if "username" in request.data:
            username = request.data.get("username")
            if username:  # Only update if not empty
                instance.user.username = username
                instance.user.save()
        
        # Update is_active status
        if "is_active" in request.data:
            instance.user.is_active = request.data.get("is_active")
            instance.user.save()

        instance.save()
        
        serializer = self.get_serializer(instance)
        return Response(serializer.data)
    
    def destroy(self, request, *args, **kwargs):
        """Delete user (can't delete shop owner)"""
        instance = self.get_object()
        
        # Check if trying to delete current user
        if instance.user == request.user:
            return Response({
                "detail": "Cannot delete your own account"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Check if trying to delete shop owner
        if instance.is_owner:
            return Response({
                "detail": "Cannot delete shop owner"
            }, status=status.HTTP_403_FORBIDDEN)
        
        # Delete the user
        username = instance.user.username
        instance.user.delete()  # This will cascade delete the profile
        
        return Response({
            "success": True,
            "message": f"User {username} deleted successfully"
        }, status=status.HTTP_200_OK)


@api_view(["GET", "PUT"])
@permission_classes([IsAuthenticated])
def shop_settings(request):
    profile = request.user.profile
    shop = profile.shop

    if request.method == "GET":
        # Get user's phone from profile or shop
        user_phone = None
        if hasattr(profile, 'phone'):
            user_phone = profile.phone
        elif hasattr(shop, 'phone'):
            user_phone = shop.phone
        
        # Return shop data with user phone
        shop_data = ShopSerializer(shop, context={'request': request}).data
        # Ensure all fields are value types (not model fields)
        for k, v in shop_data.items():
            if hasattr(v, 'value_from_object'):
                shop_data[k] = str(getattr(shop, k, v))
        shop_data['phone'] = str(user_phone or '')
        
        return Response({
            "shop": shop_data,
            "user": {
                "role": str(profile.role),
                "is_owner": bool(profile.is_owner)
            }
        })
    
    if not profile.is_owner:
        return Response({
            "detail": "Only the shop owner can update settings."
        }, status=status.HTTP_403_FORBIDDEN)

    logo_file = request.FILES.get('logo')
    if logo_file:
        shop.logo = logo_file
    

    update_data = request.data.copy()
    if 'phone' in update_data:
        del update_data['phone']
    
    serializer = ShopSerializer(shop, data=update_data, partial=True, context={'request': request})
    if serializer.is_valid():
        serializer.save()
        return Response({
            "success": True,
            "shop": serializer.data,
            "user": {
                "role": profile.role,
                "is_owner": profile.is_owner
            }
        })
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def update_user_password(request, user_id):
    """
    Update password for a user (admin can update any user's password)
    OR user can update their own password
    """
    try:
        # Get target user profile
        if user_id == request.user.profile.id:
            # User updating their own password
            target_profile = request.user.profile
        else:
            # Admin updating another user's password
            admin_profile = request.user.profile
            if admin_profile.role != 'admin':
                return Response({
                    "detail": "Only admin can update other users' passwords"
                }, status=status.HTTP_403_FORBIDDEN)
            
            target_profile = UserProfile.objects.get(
                id=user_id,
                shop=admin_profile.shop
            )
    except UserProfile.DoesNotExist:
        return Response({
            "detail": "User not found"
        }, status=status.HTTP_404_NOT_FOUND)
    
    new_password = request.data.get('password')
    if not new_password or len(new_password) < 6:
        return Response({
            "detail": "Password is required and must be at least 6 characters"
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Update password
    target_profile.user.set_password(new_password)
    target_profile.user.save()
    
    return Response({
        "success": True,
        "message": f"Password updated for {target_profile.user.username}"
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_current_user_profile(request):
    profile = request.user.profile
    shop = profile.shop

    logo_url = None
    if shop.logo:
        logo_url = request.build_absolute_uri(shop.logo.url)

    return Response({
        "id": int(profile.id),
        "user_id": int(request.user.id),
        "username": str(request.user.username),
        "email": str(request.user.email or ""),
        "role": str(profile.role),
        "is_owner": bool(profile.is_owner),
        "phone": str(profile.user.username),
        "shop": {
            "shop_id": str(shop.shop_id),
            "shop_name": str(shop.shop_name),
            "phone": str(shop.phone),
            "expire_date": str(shop.expire_date) if shop.expire_date else None,
            "logo": logo_url,
            "plan": str(shop.plan),
            "is_active": bool(shop.is_active),
            "location": str(shop.location or ""),
            "email_or_link": str(shop.email_or_link or ""),
        }
    })


# ============================================================
# NEW ENDPOINTS FOR STOCK ALERT AND DUE AMOUNT
# ============================================================

class ComprehensiveDashboardMetricsView(ShopFilterMixin, APIView):
    """Comprehensive dashboard metrics including stock alerts and due amounts"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        today = date.today()
        start_of_month = today.replace(day=1)
        
        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # 1. Sales KPIs
        today_total = (
            Sale.objects.filter(shop=shop, date__date=today).aggregate(total=Sum("total"))["total"]
            or 0
        )
        month_total = (
            Sale.objects.filter(shop=shop, date__date__gte=start_of_month).aggregate(
                total=Sum("total")
            )["total"]
            or 0
        )
        
        # VAT metrics
        today_vat = (
            Sale.objects.filter(shop=shop, date__date=today).aggregate(vat=Sum("vat_amount"))["vat"]
            or 0
        )
        month_vat = (
            Sale.objects.filter(shop=shop, date__date__gte=start_of_month).aggregate(vat=Sum("vat_amount"))["vat"]
            or 0
        )
        today_base_sales = (
            Sale.objects.filter(shop=shop, date__date=today).aggregate(subtotal=Sum("subtotal"))["subtotal"]
            or 0
        )
        month_base_sales = (
            Sale.objects.filter(shop=shop, date__date__gte=start_of_month).aggregate(subtotal=Sum("subtotal"))["subtotal"]
            or 0
        )
        
        # Total products in stock (sum of all stock)
        products_in_stock = (
            Product.objects.filter(shop=shop).aggregate(total=Sum("stock"))["total"] or 0
        )
        
        # Top product
        top_product_data = (
            SaleItem.objects.filter(sale__shop=shop, sale__date__date__gte=start_of_month)
            .values("product__id", "product__title")
            .annotate(
                qty=Sum("quantity"),
                total=Sum(
                    F("price") * F("quantity"),
                    output_field=DecimalField(max_digits=12, decimal_places=2),
                ),
            )
            .order_by("-qty")
            .first()
        )
        
        # 2. Stock Alert Summary
        threshold = 10  # Default threshold
        
        # Count products by stock status
        low_stock_count = Product.objects.filter(
            shop=shop,
            stock__gt=0,
            stock__lte=threshold
        ).count()
        
        out_of_stock_count = Product.objects.filter(
            shop=shop,
            stock=0
        ).count()
        
        healthy_stock_count = Product.objects.filter(
            shop=shop,
            stock__gt=threshold
        ).count()
        
        total_products = Product.objects.filter(shop=shop).count()
        
        # 3. Due Amount Summary
        total_customer_due = Decimal('0.00')
        customers_with_due = 0
        
        # Calculate due amounts for all customers
        all_customers = Customer.objects.filter(shop=shop)
        
        for customer in all_customers:
            # Get all sales for this customer
            customer_sales = Sale.objects.filter(customer=customer, shop=shop)
            if customer_sales.exists():
                total_sales = customer_sales.aggregate(total=Sum("total"))["total"] or Decimal('0.00')
                total_paid = customer_sales.aggregate(total=Sum("paid_amount"))["total"] or Decimal('0.00')
                
                # Add customer payments
                customer_payments = CustomerPayment.objects.filter(customer=customer, shop=shop)
                total_payments = customer_payments.aggregate(total=Sum("amount"))["total"] or Decimal('0.00')
                
                total_paid += total_payments
                customer_due = total_sales - total_paid
                
                if customer_due > Decimal('0.00'):
                    total_customer_due += customer_due
                    customers_with_due += 1
        
        # 4. Additional metrics
        total_customers = all_customers.count()
        today_sales_count = Sale.objects.filter(shop=shop, date__date=today).count()
        month_sales_count = Sale.objects.filter(shop=shop, date__date__gte=start_of_month).count()
        avg_sale_value = month_total / month_sales_count if month_sales_count > 0 else 0
        
        return Response({
            # Sales KPIs
            "today_total": float(today_total),
            "month_total": float(month_total),
            "today_vat_amount": float(today_vat),
            "month_vat_amount": float(month_vat),
            "today_base_sales": float(today_base_sales),
            "month_base_sales": float(month_base_sales),
            "products_in_stock": products_in_stock,
            "top_product": {
                "id": top_product_data["product__id"] if top_product_data else None,
                "title": top_product_data["product__title"] if top_product_data else "",
                "qty": top_product_data["qty"] if top_product_data else 0,
                "total": float(top_product_data["total"]) if top_product_data else 0,
            },
            
            # Stock Alerts
            "stock_alerts": {
                "low_stock_count": low_stock_count,
                "out_of_stock_count": out_of_stock_count,
                "healthy_stock_count": healthy_stock_count,
                "threshold": threshold,
                "has_alerts": low_stock_count > 0 or out_of_stock_count > 0,
                "stock_status_summary": {
                    "low_stock_percentage": round((low_stock_count / total_products * 100) if total_products > 0 else 0, 1),
                    "out_of_stock_percentage": round((out_of_stock_count / total_products * 100) if total_products > 0 else 0, 1),
                    "healthy_percentage": round((healthy_stock_count / total_products * 100) if total_products > 0 else 0, 1)
                }
            },
            
            # Due Amounts
            "total_due_amount": float(total_customer_due),
            "total_customers_with_due": customers_with_due,
            "average_due_per_customer": float(total_customer_due / customers_with_due) if customers_with_due > 0 else 0,
            
            # Additional metrics
            "total_products": total_products,
            "total_customers": total_customers,
            "today_sales_count": today_sales_count,
            "month_sales_count": month_sales_count,
            "average_sale_value": float(avg_sale_value),
            
            # Timestamps
            "report_date": str(today),
            "month_start_date": str(start_of_month),
            "month_label": today.strftime("%B %Y")
        })


class StockAlertDashboardView(ShopFilterMixin, APIView):
    """Get stock alerts for dashboard"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        # Get threshold from query param or use default
        threshold = int(request.GET.get("threshold", 10))
        
        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # Get products with low stock (below threshold but > 0)
        low_stock_products = Product.objects.filter(
            shop=shop,
            stock__gt=0,
            stock__lte=threshold
        ).order_by('stock').select_related('category')[:10]  # Limit to 10
        
        # Get products that are completely out of stock
        out_of_stock_products = Product.objects.filter(
            shop=shop,
            stock=0
        ).order_by('title').select_related('category')[:10]  # Limit to 10
        
        # Serialize low stock products
        low_stock_data = []
        for product in low_stock_products:
            low_stock_data.append({
                'id': product.id,
                'title': product.title,
                'product_code': product.product_code,
                'current_stock': product.stock,
                'threshold': threshold,
                'category': product.category.name if product.category else 'Uncategorized',
                'selling_price': float(product.selling_price) if product.selling_price else 0,
                'purchased_price': float(product.purchased_price) if product.purchased_price else 0,
                'stock_value': float(product.stock * product.purchased_price) if product.purchased_price else 0,
                'status': 'low_stock',
                'alert_level': 'warning'
            })
        
        # Serialize out of stock products
        out_of_stock_data = []
        for product in out_of_stock_products:
            out_of_stock_data.append({
                'id': product.id,
                'title': product.title,
                'product_code': product.product_code,
                'current_stock': product.stock,
                'threshold': threshold,
                'category': product.category.name if product.category else 'Uncategorized',
                'selling_price': float(product.selling_price) if product.selling_price else 0,
                'purchased_price': float(product.purchased_price) if product.purchased_price else 0,
                'stock_value': 0,
                'status': 'out_of_stock',
                'alert_level': 'critical'
            })
        
        # Combine both lists
        all_alert_products = low_stock_data + out_of_stock_data
        
        # Get statistics
        total_products = Product.objects.filter(shop=shop).count()
        low_stock_count = Product.objects.filter(
            shop=shop,
            stock__gt=0,
            stock__lte=threshold
        ).count()
        out_of_stock_count = Product.objects.filter(
            shop=shop,
            stock=0
        ).count()
        
        # Calculate estimated revenue loss from out of stock
        estimated_revenue_loss = sum(
            product['selling_price'] * 3  # Assuming avg 3 units could have been sold
            for product in out_of_stock_data
        )
        
        return Response({
            'threshold': threshold,
            'all_alert_products': all_alert_products,
            'low_stock_products': low_stock_data,
            'out_of_stock_products': out_of_stock_data,
            'stats': {
                'total_low_stock': low_stock_count,
                'out_of_stock': out_of_stock_count,
                'total_products': total_products,
                'total_alerts': low_stock_count + out_of_stock_count,
                'percentage_low_stock': round((low_stock_count / total_products * 100) if total_products > 0 else 0, 1),
                'percentage_out_of_stock': round((out_of_stock_count / total_products * 100) if total_products > 0 else 0, 1),
                'estimated_revenue_loss': estimated_revenue_loss
            }
        })


class DueAmountDashboardView(ShopFilterMixin, APIView):
    """Get due amounts for dashboard"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        # Calculate total due from customers
        customers = Customer.objects.filter(shop=shop)
        
        total_due = Decimal('0.00')
        customers_with_due = []
        
        for customer in customers:
            # Calculate customer's total due
            sales = Sale.objects.filter(customer=customer, shop=shop)
            payments = CustomerPayment.objects.filter(customer=customer, shop=shop)
            
            total_sales = sales.aggregate(total=Coalesce(Sum("total"), Decimal("0.00")))["total"]
            total_paid_from_sales = sales.aggregate(total=Coalesce(Sum("paid_amount"), Decimal("0.00")))["total"]
            total_paid_from_payments = payments.aggregate(total=Coalesce(Sum("amount"), Decimal("0.00")))["total"]
            total_paid = total_paid_from_sales + total_paid_from_payments
            customer_due = total_sales - total_paid
            
            if customer_due > Decimal('0.00'):
                # Get last sale date
                last_sale = sales.order_by('-date').first()
                
                customers_with_due.append({
                    'id': customer.id,
                    'name': customer.name,
                    'phone': customer.phone,
                    'due_amount': float(customer_due),
                    'last_sale_date': last_sale.date if last_sale else None,
                    'total_purchases': float(total_sales) if total_sales else 0,
                })
                total_due += customer_due
        
        # Sort customers by highest due
        customers_with_due.sort(key=lambda x: x['due_amount'], reverse=True)
        
        # Get top 5 customers
        top_customers = customers_with_due[:5]
        
        return Response({
            'customer_due_summary': {
                'total_due': float(total_due),
                'total_customers_with_due': len(customers_with_due),
                'customers': top_customers,
                'average_due_per_customer': float(total_due / len(customers_with_due)) if customers_with_due else 0
            }
        })
    

# Add this to views.py

class QuickRestockView(ShopFilterMixin, APIView):
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        """Quick restock from dashboard"""
        product_id = request.data.get('product_id')
        quantity = int(request.data.get('quantity', 10))
        purchase_price = request.data.get('purchase_price')
        supplier_id = request.data.get('supplier_id')
        
        # Get current shop
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        try:
            product = Product.objects.get(id=product_id, shop=shop)
        except Product.DoesNotExist:

            return Response({"error": "Product not found"}, status=404)


# ============================================================
# CASH TRANSACTION / LEDGER VIEWS
# ============================================================

class CashTransactionListAPIView(ShopFilterMixin, APIView):
    """List all cash transactions with filters and summary"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        # Get query params
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        transaction_type = request.GET.get('transaction_type')  # credit/debit
        source = request.GET.get('source')  # sale, expense, purchase, etc.
        payment_method = request.GET.get('payment_method')
        
        # Base queryset
        queryset = CashTransaction.objects.filter(shop=shop)
        
        # Apply filters
        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])
        elif start_date:
            queryset = queryset.filter(date__gte=start_date)
        elif end_date:
            queryset = queryset.filter(date__lte=end_date)
        
        if transaction_type:
            queryset = queryset.filter(transaction_type=transaction_type)
        
        if source:
            queryset = queryset.filter(source=source)
        
        if payment_method:
            queryset = queryset.filter(payment_method=payment_method)
        
        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(
                Sum('amount', filter=Q(transaction_type='credit')),
                Decimal('0.00')
            ),
            total_debit=Coalesce(
                Sum('amount', filter=Q(transaction_type='debit')),
                Decimal('0.00')
            )
        )
        
        # Current balance (all-time)
        current_balance = CashTransaction.get_current_balance(shop)
        
        # Period balance
        period_balance = summary['total_credit'] - summary['total_debit']
        
        # Serialize transactions
        serializer = CashTransactionSerializer(queryset, many=True)
        
        return Response({
            'transactions': serializer.data,
            'summary': {
                'total_credit': float(summary['total_credit']),
                'total_debit': float(summary['total_debit']),
                'period_balance': float(period_balance),
                'current_balance': float(current_balance)
            }
        })


class CashTransactionCreateAPIView(ShopFilterMixin, APIView):
    """Create a manual cash transaction"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def post(self, request):
        serializer = CashTransactionCreateSerializer(data=request.data, context={'request': request})
        
        if serializer.is_valid():
            transaction = serializer.save()
            return Response(
                CashTransactionSerializer(transaction).data,
                status=status.HTTP_201_CREATED
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class CashTransactionSyncAPIView(ShopFilterMixin, APIView):
    """Sync transactions from Sales, Expenses, Purchases, Payments"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def post(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        start_date = request.data.get('start_date')
        end_date = request.data.get('end_date')
        
        synced_count = {
            'sales': 0,
            'expenses': 0,
            'purchases': 0,
            'supplier_payments': 0,
            'customer_payments': 0
        }
        
        # Sync Sales (Credit - money coming in)
        sales_filter = {'shop': shop}
        if start_date and end_date:
            sales_filter['date__date__range'] = [start_date, end_date]
        
        sales = Sale.objects.filter(**sales_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='sale').values_list('sale_id', flat=True)
        )
        
        for sale in sales:
            # Only create transaction for non-due payments
            if sale.payment_method != 'due':
                CashTransaction.objects.create(
                    shop=shop,
                    date=sale.date.date() if hasattr(sale.date, 'date') else sale.date,
                    transaction_type='credit',
                    source='sale',
                    amount=sale.total,
                    payment_method=sale.payment_method if sale.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                    sale=sale,
                    description=f"Sale to {sale.customer.name if sale.customer else 'Walk-in Customer'}",
                    created_by=request.user
                )
                synced_count['sales'] += 1
        
        # Sync Expenses (Debit - money going out)
        expenses_filter = {'shop': shop}
        if start_date and end_date:
            expenses_filter['date__range'] = [start_date, end_date]
        
        expenses = Expense.objects.filter(**expenses_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='expense').values_list('expense_id', flat=True)
        )
        
        for expense in expenses:
            CashTransaction.objects.create(
                shop=shop,
                date=expense.date,
                transaction_type='debit',
                source='expense',
                amount=expense.amount,
                payment_method=expense.payment_method if expense.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                expense=expense,
                description=f"{expense.category}: {expense.description}" if expense.description else expense.category,
                created_by=request.user
            )
            synced_count['expenses'] += 1
        
        # Sync Purchases (Debit - money going out for paid purchases)
        purchases_filter = {'shop': shop}
        if start_date and end_date:
            purchases_filter['date__range'] = [start_date, end_date]
        
        purchases = Purchase.objects.filter(**purchases_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='purchase').values_list('purchase_id', flat=True)
        )
        
        for purchase in purchases:
            # Only sync the paid amount
            if purchase.paid_amount > 0:
                CashTransaction.objects.create(
                    shop=shop,
                    date=purchase.date,
                    transaction_type='debit',
                    source='purchase',
                    amount=purchase.paid_amount,
                    payment_method=purchase.payment_method if purchase.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                    purchase=purchase,
                    description=f"Purchase from {purchase.supplier.name} - Invoice: {purchase.invoice_no}",
                    created_by=request.user
                )
                synced_count['purchases'] += 1
        
        # Sync Supplier Payments (Debit - paying supplier dues)
        supplier_payments_filter = {'shop': shop}
        if start_date and end_date:
            supplier_payments_filter['date__range'] = [start_date, end_date]
        
        supplier_payments = SupplierPayment.objects.filter(**supplier_payments_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='supplier_payment').values_list('supplier_payment_id', flat=True)
        )
        
        for payment in supplier_payments:
            CashTransaction.objects.create(
                shop=shop,
                date=payment.date,
                transaction_type='debit',
                source='supplier_payment',
                amount=payment.amount,
                payment_method=payment.payment_method if payment.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                supplier_payment=payment,
                description=f"Payment to supplier: {payment.supplier.name}",
                reference_no=payment.memo_no,
                created_by=request.user
            )
            synced_count['supplier_payments'] += 1
        
        # Sync Customer Payments (Credit - collecting customer dues)
        customer_payments_filter = {'shop': shop}
        if start_date and end_date:
            customer_payments_filter['date__range'] = [start_date, end_date]
        
        customer_payments = CustomerPayment.objects.filter(**customer_payments_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='customer_payment').values_list('customer_payment_id', flat=True)
        )
        
        for payment in customer_payments:
            CashTransaction.objects.create(
                shop=shop,
                date=payment.date,
                transaction_type='credit',
                source='customer_payment',
                amount=payment.amount,
                payment_method=payment.payment_method if payment.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                customer_payment=payment,
                description=f"Due payment from customer: {payment.customer.name}",
                reference_no=payment.memo_no,
                created_by=request.user
            )
            synced_count['customer_payments'] += 1
        
        return Response({
            'message': 'Sync completed successfully',
            'synced': synced_count,
            'total': sum(synced_count.values())
        })


class CashTransactionSummaryAPIView(ShopFilterMixin, APIView):
    """Get transaction summary with breakdown by source"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        
        # Base queryset
        queryset = CashTransaction.objects.filter(shop=shop)
        
        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])
        
        # Summary by source
        source_summary = queryset.values('source', 'transaction_type').annotate(
            total=Sum('amount'),
            count=Count('id')
        ).order_by('source')
        
        # Daily summary
        daily_summary = queryset.values('date').annotate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        ).order_by('date')
        
        # Overall totals
        totals = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )
        
        current_balance = CashTransaction.get_current_balance(shop)
        
        return Response({
            'source_summary': list(source_summary),
            'daily_summary': list(daily_summary),
            'totals': {
                'total_credit': float(totals['total_credit']),
                'total_debit': float(totals['total_debit']),
                'net_balance': float(totals['total_credit'] - totals['total_debit']),
                'current_balance': float(current_balance)
            }
        })


class CashTransactionDeleteAPIView(ShopFilterMixin, APIView):
    """Delete a manual transaction (only manual entries can be deleted)"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def delete(self, request, pk):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        try:
            transaction = CashTransaction.objects.get(pk=pk, shop=shop)
            
            if not transaction.is_manual:
                return Response(
                    {"error": "Cannot delete auto-synced transactions. Delete the original record instead."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            transaction.delete()
            return Response({"message": "Transaction deleted successfully"}, status=status.HTTP_204_NO_CONTENT)
        
        except CashTransaction.DoesNotExist:
            return Response({"error": "Transaction not found"}, status=status.HTTP_404_NOT_FOUND)


class OpeningBalanceAPIView(ShopFilterMixin, APIView):
    """Set or update opening balance for the shop"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        # Get opening balance transaction
        opening = CashTransaction.objects.filter(
            shop=shop,
            source='opening_balance'
        ).first()
        
        if opening:
            return Response({
                'has_opening_balance': True,
                'amount': float(opening.amount),
                'date': opening.date,
                'id': opening.id
            })
        
        return Response({
            'has_opening_balance': False,
            'amount': 0,
            'date': None
        })
    
    def post(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        amount = request.data.get('amount', 0)
        date_str = request.data.get('date')
        
        try:
            amount = Decimal(str(amount))
        except:
            return Response({"error": "Invalid amount"}, status=400)
        
        # Check if opening balance already exists
        existing = CashTransaction.objects.filter(
            shop=shop,
            source='opening_balance'
        ).first()
        
        if existing:
            existing.amount = amount
            if date_str:
                existing.date = date_str
            existing.save()
            return Response({
                'message': 'Opening balance updated',
                'amount': float(existing.amount),
                'date': existing.date
            })
        
        # Create new opening balance
        opening = CashTransaction.objects.create(
            shop=shop,
            date=date_str or date.today(),
            transaction_type='credit',
            source='opening_balance',
            amount=amount,
            payment_method='cash',
            description='Opening Balance',
            is_manual=True,
            created_by=request.user
        )
        
        return Response({
            'message': 'Opening balance set',
            'amount': float(opening.amount),
            'date': opening.date

        }, status=status.HTTP_201_CREATED)


# ============================================================
# CASH TRANSACTION EXPORT VIEWS (PDF & EXCEL)
# ============================================================

class CashTransactionExportPDF(ShopFilterMixin, APIView):
    """Export cash transactions to PDF"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        from reportlab.lib.pagesizes import A4
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
        from reportlab.lib.styles import getSampleStyleSheet
        from reportlab.lib import colors
        from io import BytesIO

        profile = request.user.profile
        shop = profile.shop if profile else None

        if not shop:
            return Response({"error": "No shop associated"}, status=400)

        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Build query
        queryset = CashTransaction.objects.filter(shop=shop).order_by('date', 'created_at')

        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])

        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )

        # Create PDF
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=30, bottomMargin=30)
        styles = getSampleStyleSheet()
        story = []

        # Title
        story.append(Paragraph(f"Cash Ledger Report - {shop.shop_name}", styles["Title"]))
        if start_date and end_date:
            story.append(Paragraph(f"Period: {start_date} to {end_date}", styles["Normal"]))
        story.append(Spacer(1, 20))

        # Summary table
        summary_data = [
            ["Summary", "Amount (৳)"],
            ["Total Credit (In)", f"{summary['total_credit']:.2f}"],
            ["Total Debit (Out)", f"{summary['total_debit']:.2f}"],
            ["Net Balance", f"{(summary['total_credit'] - summary['total_debit']):.2f}"],
        ]
        summary_table = Table(summary_data, colWidths=[200, 150])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3B82F6')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F3F4F6')),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ]))
        story.append(summary_table)
        story.append(Spacer(1, 20))

        # Transaction details header
        story.append(Paragraph("Transaction Details", styles["Heading2"]))
        story.append(Spacer(1, 10))

        # Transaction table
        table_data = [["Date", "Type", "Source", "Description", "Credit (৳)", "Debit (৳)"]]

        running_balance = Decimal('0.00')
        for t in queryset:
            credit = f"{t.amount:.2f}" if t.transaction_type == 'credit' else "—"
            debit = f"{t.amount:.2f}" if t.transaction_type == 'debit' else "—"
            desc = t.description[:30] + "..." if t.description and len(t.description) > 30 else (t.description or t.get_source_display())

            table_data.append([
                str(t.date),
                t.get_transaction_type_display(),
                t.get_source_display(),
                desc,
                credit,
                debit
            ])

        if len(table_data) > 1:
            trans_table = Table(table_data, colWidths=[70, 50, 80, 120, 70, 70])
            trans_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10B981')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F9FAFB')]),
            ]))
            story.append(trans_table)
        else:
            story.append(Paragraph("No transactions found for the selected period.", styles["Normal"]))

        doc.build(story)
        buffer.seek(0)

        response = HttpResponse(buffer, content_type="application/pdf")
        response["Content-Disposition"] = f'attachment; filename="cash_ledger_{start_date or "all"}_{end_date or "all"}.pdf"'
        return response


class CashTransactionExportExcel(ShopFilterMixin, APIView):
    """Export cash transactions to Excel"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO

        profile = request.user.profile
        shop = profile.shop if profile else None

        if not shop:
            return Response({"error": "No shop associated"}, status=400)

        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Build query
        queryset = CashTransaction.objects.filter(shop=shop).order_by('date', 'created_at')

        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])

        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )

        # Create workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Cash Ledger"

        # Styles
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="3B82F6", end_color="3B82F6", fill_type="solid")
        green_fill = PatternFill(start_color="10B981", end_color="10B981", fill_type="solid")
        thin_border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )

        # Title
        ws.append([f"Cash Ledger Report - {shop.shop_name}"])
        ws.merge_cells('A1:F1')
        ws['A1'].font = Font(bold=True, size=14)
        ws['A1'].alignment = Alignment(horizontal='center')

        if start_date and end_date:
            ws.append([f"Period: {start_date} to {end_date}"])
            ws.merge_cells('A2:F2')
            ws['A2'].alignment = Alignment(horizontal='center')

        ws.append([])  # Empty row

        # Summary section
        ws.append(["Summary", "Amount (৳)"])
        ws.append(["Total Credit (In)", float(summary['total_credit'])])
        ws.append(["Total Debit (Out)", float(summary['total_debit'])])
        ws.append(["Net Balance", float(summary['total_credit'] - summary['total_debit'])])

        ws.append([])  # Empty row

        # Transaction details header
        headers = ["Date", "Type", "Source", "Description", "Credit (৳)", "Debit (৳)", "Payment Method", "Reference"]
        ws.append(headers)
        header_row = ws.max_row
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=header_row, column=col)
            cell.font = header_font
            cell.fill = green_fill
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        # Transaction data
        for t in queryset:
            credit = float(t.amount) if t.transaction_type == 'credit' else ""
            debit = float(t.amount) if t.transaction_type == 'debit' else ""

            ws.append([
                str(t.date),
                t.get_transaction_type_display(),
                t.get_source_display(),
                t.description or t.get_source_display(),
                credit,
                debit,
                t.get_payment_method_display(),
                t.reference_no or ""
            ])

        # Adjust column widths
        ws.column_dimensions['A'].width = 12
        ws.column_dimensions['B'].width = 10
        ws.column_dimensions['C'].width = 18
        ws.column_dimensions['D'].width = 35
        ws.column_dimensions['E'].width = 12
        ws.column_dimensions['F'].width = 12
        ws.column_dimensions['G'].width = 15
        ws.column_dimensions['H'].width = 15

        # Save to buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)

        response = HttpResponse(
            buffer,
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        response["Content-Disposition"] = f'attachment; filename="cash_ledger_{start_date or "all"}_{end_date or "all"}.xlsx"'
        return response


        
        # Get or create default supplier if none provided
        if supplier_id:
            try:
                supplier = Supplier.objects.get(id=supplier_id, shop=shop)
            except Supplier.DoesNotExist:
                return Response({"error": "Supplier not found"}, status=404)
        else:
            # Use default supplier or create one
            supplier = Supplier.objects.filter(shop=shop).first()
            if not supplier:
                supplier = Supplier.objects.create(
                    shop=shop,
                    name="General Supplier",
                    phone="N/A"
                )
        
        # Generate invoice number
        import time
        invoice_no = f"QR-{int(time.time())}"
        
        # Calculate purchase price
        if not purchase_price:
            # Use product's purchased price or 80% of regular price
            purchase_price = product.purchased_price if product.purchased_price > 0 else product.regular_price * 0.8
        
        total = Decimal(purchase_price) * Decimal(quantity)
        
        # Create purchase
        purchase = Purchase.objects.create(
            shop=shop,
            supplier=supplier,
            invoice_no=invoice_no,
            date=date.today(),
            subtotal=total,
            total=total,
            paid_amount=total,
            payment_method="cash",
            remarks=f"Quick restock from dashboard - Previous stock: {product.stock}"
        )
        
        # Create purchase item
        purchase_item = PurchaseItem.objects.create(
            purchase=purchase,
            product=product,
            quantity=quantity,
            purchase_price=purchase_price,
            total=total
        )
        
        # Update product stock
        old_stock = product.stock
        product.stock += quantity
        product.save()
        
        return Response({
            "success": True,
            "message": f"Successfully restocked {quantity} units of {product.title}",
            "data": {
                "purchase_id": purchase.id,
                "invoice_no": purchase.invoice_no,
                "product": product.title,
                "quantity": quantity,
                "purchase_price": float(purchase_price),
                "total": float(total),
                "old_stock": old_stock,
                "new_stock": product.stock,
                "supplier": supplier.name
            }
        }, status=201)
    
    def get(self, request):
        """Get product and supplier info for quick restock"""
        product_id = request.GET.get('product_id')
        
        if not product_id:
            return Response({"error": "Product ID is required"}, status=400)
        
        try:
            product = Product.objects.get(id=product_id)
            
            # Get suggested quantity based on current stock
            suggested_quantity = 0
            if product.stock == 0:
                suggested_quantity = 20  # For out of stock
            elif product.stock <= 5:
                suggested_quantity = 15  # For very low stock
            elif product.stock <= 10:
                suggested_quantity = 10  # For low stock
            
            # Get last purchase price
            last_purchase_item = PurchaseItem.objects.filter(
                product=product
            ).order_by('-purchase__date').first()
            
            last_price = None
            if last_purchase_item:
                last_price = float(last_purchase_item.purchase_price)
            
            # Get recent suppliers for this product
            recent_suppliers = Supplier.objects.filter(
                purchase__items__product=product
            ).distinct().order_by('-purchase__date')[:5]
            
            # Get all suppliers for dropdown
            all_suppliers = Supplier.objects.filter(shop=product.shop).order_by('name')
            
            return Response({
                "product": {
                    "id": product.id,
                    "title": product.title,
                    "current_stock": product.stock,
                    "purchased_price": float(product.purchased_price) if product.purchased_price else None,
                    "regular_price": float(product.regular_price),
                    "selling_price": float(product.selling_price) if product.selling_price else None,
                    "product_code": product.product_code,
                    "category": product.category.name if product.category else None
                },
                "suggested_quantity": suggested_quantity,
                "last_purchase_price": last_price,
                "recent_suppliers": [
                    {
                        "id": s.id,
                        "name": s.name,
                        "phone": s.phone
                    } for s in recent_suppliers
                ],
                "all_suppliers": [
                    {
                        "id": s.id,
                        "name": s.name,
                        "phone": s.phone
                    } for s in all_suppliers
                ]
            })
            
        except Product.DoesNotExist:

            return Response({"error": "Product not found"}, status=404)


# ============================================================
# CASH TRANSACTION / LEDGER VIEWS
# ============================================================

class CashTransactionListAPIView(ShopFilterMixin, APIView):
    """List all cash transactions with filters and summary"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        # Get query params
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        transaction_type = request.GET.get('transaction_type')  # credit/debit
        source = request.GET.get('source')  # sale, expense, purchase, etc.
        payment_method = request.GET.get('payment_method')
        
        # Base queryset
        queryset = CashTransaction.objects.filter(shop=shop)
        
        # Apply filters
        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])
        elif start_date:
            queryset = queryset.filter(date__gte=start_date)
        elif end_date:
            queryset = queryset.filter(date__lte=end_date)
        
        if transaction_type:
            queryset = queryset.filter(transaction_type=transaction_type)
        
        if source:
            queryset = queryset.filter(source=source)
        
        if payment_method:
            queryset = queryset.filter(payment_method=payment_method)
        
        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(
                Sum('amount', filter=Q(transaction_type='credit')),
                Decimal('0.00')
            ),
            total_debit=Coalesce(
                Sum('amount', filter=Q(transaction_type='debit')),
                Decimal('0.00')
            )
        )
        
        # Current balance (all-time)
        current_balance = CashTransaction.get_current_balance(shop)
        
        # Period balance
        period_balance = summary['total_credit'] - summary['total_debit']
        
        # Serialize transactions
        serializer = CashTransactionSerializer(queryset, many=True)
        
        return Response({
            'transactions': serializer.data,
            'summary': {
                'total_credit': float(summary['total_credit']),
                'total_debit': float(summary['total_debit']),
                'period_balance': float(period_balance),
                'current_balance': float(current_balance)
            }
        })


class CashTransactionCreateAPIView(ShopFilterMixin, APIView):
    """Create a manual cash transaction"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def post(self, request):
        serializer = CashTransactionCreateSerializer(data=request.data, context={'request': request})
        
        if serializer.is_valid():
            transaction = serializer.save()
            return Response(
                CashTransactionSerializer(transaction).data,
                status=status.HTTP_201_CREATED
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class CashTransactionSyncAPIView(ShopFilterMixin, APIView):
    """Sync transactions from Sales, Expenses, Purchases, Payments"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def post(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        start_date = request.data.get('start_date')
        end_date = request.data.get('end_date')
        
        synced_count = {
            'sales': 0,
            'expenses': 0,
            'purchases': 0,
            'supplier_payments': 0,
            'customer_payments': 0
        }
        
        # Sync Sales (Credit - money coming in)
        sales_filter = {'shop': shop}
        if start_date and end_date:
            sales_filter['date__date__range'] = [start_date, end_date]
        
        sales = Sale.objects.filter(**sales_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='sale').values_list('sale_id', flat=True)
        )
        
        for sale in sales:
            # Only create transaction for non-due payments
            if sale.payment_method != 'due':
                CashTransaction.objects.create(
                    shop=shop,
                    date=sale.date.date() if hasattr(sale.date, 'date') else sale.date,
                    transaction_type='credit',
                    source='sale',
                    amount=sale.total,
                    payment_method=sale.payment_method if sale.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                    sale=sale,
                    description=f"Sale to {sale.customer.name if sale.customer else 'Walk-in Customer'}",
                    created_by=request.user
                )
                synced_count['sales'] += 1
        
        # Sync Expenses (Debit - money going out)
        expenses_filter = {'shop': shop}
        if start_date and end_date:
            expenses_filter['date__range'] = [start_date, end_date]
        
        expenses = Expense.objects.filter(**expenses_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='expense').values_list('expense_id', flat=True)
        )
        
        for expense in expenses:
            CashTransaction.objects.create(
                shop=shop,
                date=expense.date,
                transaction_type='debit',
                source='expense',
                amount=expense.amount,
                payment_method=expense.payment_method if expense.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                expense=expense,
                description=f"{expense.category}: {expense.description}" if expense.description else expense.category,
                created_by=request.user
            )
            synced_count['expenses'] += 1
        
        # Sync Purchases (Debit - money going out for paid purchases)
        purchases_filter = {'shop': shop}
        if start_date and end_date:
            purchases_filter['date__range'] = [start_date, end_date]
        
        purchases = Purchase.objects.filter(**purchases_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='purchase').values_list('purchase_id', flat=True)
        )
        
        for purchase in purchases:
            # Only sync the paid amount
            if purchase.paid_amount > 0:
                CashTransaction.objects.create(
                    shop=shop,
                    date=purchase.date,
                    transaction_type='debit',
                    source='purchase',
                    amount=purchase.paid_amount,
                    payment_method=purchase.payment_method if purchase.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                    purchase=purchase,
                    description=f"Purchase from {purchase.supplier.name} - Invoice: {purchase.invoice_no}",
                    created_by=request.user
                )
                synced_count['purchases'] += 1
        
        # Sync Supplier Payments (Debit - paying supplier dues)
        supplier_payments_filter = {'shop': shop}
        if start_date and end_date:
            supplier_payments_filter['date__range'] = [start_date, end_date]
        
        supplier_payments = SupplierPayment.objects.filter(**supplier_payments_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='supplier_payment').values_list('supplier_payment_id', flat=True)
        )
        
        for payment in supplier_payments:
            CashTransaction.objects.create(
                shop=shop,
                date=payment.date,
                transaction_type='debit',
                source='supplier_payment',
                amount=payment.amount,
                payment_method=payment.payment_method if payment.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                supplier_payment=payment,
                description=f"Payment to supplier: {payment.supplier.name}",
                reference_no=payment.memo_no,
                created_by=request.user
            )
            synced_count['supplier_payments'] += 1
        
        # Sync Customer Payments (Credit - collecting customer dues)
        customer_payments_filter = {'shop': shop}
        if start_date and end_date:
            customer_payments_filter['date__range'] = [start_date, end_date]
        
        customer_payments = CustomerPayment.objects.filter(**customer_payments_filter).exclude(
            id__in=CashTransaction.objects.filter(shop=shop, source='customer_payment').values_list('customer_payment_id', flat=True)
        )
        
        for payment in customer_payments:
            CashTransaction.objects.create(
                shop=shop,
                date=payment.date,
                transaction_type='credit',
                source='customer_payment',
                amount=payment.amount,
                payment_method=payment.payment_method if payment.payment_method in ['cash', 'bank', 'bkash', 'nagad', 'card'] else 'cash',
                customer_payment=payment,
                description=f"Due payment from customer: {payment.customer.name}",
                reference_no=payment.memo_no,
                created_by=request.user
            )
            synced_count['customer_payments'] += 1
        
        return Response({
            'message': 'Sync completed successfully',
            'synced': synced_count,
            'total': sum(synced_count.values())
        })


class CashTransactionSummaryAPIView(ShopFilterMixin, APIView):
    """Get transaction summary with breakdown by source"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')
        
        # Base queryset
        queryset = CashTransaction.objects.filter(shop=shop)
        
        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])
        
        # Summary by source
        source_summary = queryset.values('source', 'transaction_type').annotate(
            total=Sum('amount'),
            count=Count('id')
        ).order_by('source')
        
        # Daily summary
        daily_summary = queryset.values('date').annotate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        ).order_by('date')
        
        # Overall totals
        totals = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )
        
        current_balance = CashTransaction.get_current_balance(shop)
        
        return Response({
            'source_summary': list(source_summary),
            'daily_summary': list(daily_summary),
            'totals': {
                'total_credit': float(totals['total_credit']),
                'total_debit': float(totals['total_debit']),
                'net_balance': float(totals['total_credit'] - totals['total_debit']),
                'current_balance': float(current_balance)
            }
        })


class CashTransactionDeleteAPIView(ShopFilterMixin, APIView):
    """Delete a manual transaction (only manual entries can be deleted)"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def delete(self, request, pk):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        try:
            transaction = CashTransaction.objects.get(pk=pk, shop=shop)
            
            if not transaction.is_manual:
                return Response(
                    {"error": "Cannot delete auto-synced transactions. Delete the original record instead."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            transaction.delete()
            return Response({"message": "Transaction deleted successfully"}, status=status.HTTP_204_NO_CONTENT)
        
        except CashTransaction.DoesNotExist:
            return Response({"error": "Transaction not found"}, status=status.HTTP_404_NOT_FOUND)


class OpeningBalanceAPIView(ShopFilterMixin, APIView):
    """Set or update opening balance for the shop"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]
    
    def get(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        # Get opening balance transaction
        opening = CashTransaction.objects.filter(
            shop=shop,
            source='opening_balance'
        ).first()
        
        if opening:
            return Response({
                'has_opening_balance': True,
                'amount': float(opening.amount),
                'date': opening.date,
                'id': opening.id
            })
        
        return Response({
            'has_opening_balance': False,
            'amount': 0,
            'date': None
        })
    
    def post(self, request):
        profile = request.user.profile
        shop = profile.shop if profile else None
        
        if not shop:
            return Response({"error": "No shop associated"}, status=400)
        
        amount = request.data.get('amount', 0)
        date_str = request.data.get('date')
        
        try:
            amount = Decimal(str(amount))
        except:
            return Response({"error": "Invalid amount"}, status=400)
        
        # Check if opening balance already exists
        existing = CashTransaction.objects.filter(
            shop=shop,
            source='opening_balance'
        ).first()
        
        if existing:
            existing.amount = amount
            if date_str:
                existing.date = date_str
            existing.save()
            return Response({
                'message': 'Opening balance updated',
                'amount': float(existing.amount),
                'date': existing.date
            })
        
        # Create new opening balance
        opening = CashTransaction.objects.create(
            shop=shop,
            date=date_str or date.today(),
            transaction_type='credit',
            source='opening_balance',
            amount=amount,
            payment_method='cash',
            description='Opening Balance',
            is_manual=True,
            created_by=request.user
        )
        
        return Response({
            'message': 'Opening balance set',
            'amount': float(opening.amount),
            'date': opening.date

        }, status=status.HTTP_201_CREATED)


# ============================================================
# CASH TRANSACTION EXPORT VIEWS (PDF & EXCEL)
# ============================================================

class CashTransactionExportPDF(ShopFilterMixin, APIView):
    """Export cash transactions to PDF"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        from reportlab.lib.pagesizes import A4
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
        from reportlab.lib.styles import getSampleStyleSheet
        from reportlab.lib import colors
        from io import BytesIO

        profile = request.user.profile
        shop = profile.shop if profile else None

        if not shop:
            return Response({"error": "No shop associated"}, status=400)

        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Build query
        queryset = CashTransaction.objects.filter(shop=shop).order_by('date', 'created_at')

        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])

        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )

        # Create PDF
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=30, bottomMargin=30)
        styles = getSampleStyleSheet()
        story = []

        # Title
        story.append(Paragraph(f"Cash Ledger Report - {shop.shop_name}", styles["Title"]))
        if start_date and end_date:
            story.append(Paragraph(f"Period: {start_date} to {end_date}", styles["Normal"]))
        story.append(Spacer(1, 20))

        # Summary table
        summary_data = [
            ["Summary", "Amount (৳)"],
            ["Total Credit (In)", f"{summary['total_credit']:.2f}"],
            ["Total Debit (Out)", f"{summary['total_debit']:.2f}"],
            ["Net Balance", f"{(summary['total_credit'] - summary['total_debit']):.2f}"],
        ]
        summary_table = Table(summary_data, colWidths=[200, 150])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3B82F6')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F3F4F6')),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ]))
        story.append(summary_table)
        story.append(Spacer(1, 20))

        # Transaction details header
        story.append(Paragraph("Transaction Details", styles["Heading2"]))
        story.append(Spacer(1, 10))

        # Transaction table
        table_data = [["Date", "Type", "Source", "Description", "Credit (৳)", "Debit (৳)"]]

        running_balance = Decimal('0.00')
        for t in queryset:
            credit = f"{t.amount:.2f}" if t.transaction_type == 'credit' else "—"
            debit = f"{t.amount:.2f}" if t.transaction_type == 'debit' else "—"
            desc = t.description[:30] + "..." if t.description and len(t.description) > 30 else (t.description or t.get_source_display())

            table_data.append([
                str(t.date),
                t.get_transaction_type_display(),
                t.get_source_display(),
                desc,
                credit,
                debit
            ])

        if len(table_data) > 1:
            trans_table = Table(table_data, colWidths=[70, 50, 80, 120, 70, 70])
            trans_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10B981')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F9FAFB')]),
            ]))
            story.append(trans_table)
        else:
            story.append(Paragraph("No transactions found for the selected period.", styles["Normal"]))

        doc.build(story)
        buffer.seek(0)

        response = HttpResponse(buffer, content_type="application/pdf")
        response["Content-Disposition"] = f'attachment; filename="cash_ledger_{start_date or "all"}_{end_date or "all"}.pdf"'
        return response


class CashTransactionExportExcel(ShopFilterMixin, APIView):
    """Export cash transactions to Excel"""
    permission_classes = [permissions.IsAuthenticated, RoleBasedAccessPermission]

    def get(self, request):
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from io import BytesIO

        profile = request.user.profile
        shop = profile.shop if profile else None

        if not shop:
            return Response({"error": "No shop associated"}, status=400)

        start_date = request.GET.get("start_date")
        end_date = request.GET.get("end_date")

        # Build query
        queryset = CashTransaction.objects.filter(shop=shop).order_by('date', 'created_at')

        if start_date and end_date:
            queryset = queryset.filter(date__range=[start_date, end_date])

        # Calculate summary
        summary = queryset.aggregate(
            total_credit=Coalesce(Sum('amount', filter=Q(transaction_type='credit')), Decimal('0.00')),
            total_debit=Coalesce(Sum('amount', filter=Q(transaction_type='debit')), Decimal('0.00'))
        )

        # Create workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Cash Ledger"

        # Styles
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="3B82F6", end_color="3B82F6", fill_type="solid")
        green_fill = PatternFill(start_color="10B981", end_color="10B981", fill_type="solid")
        thin_border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )

        # Title
        ws.append([f"Cash Ledger Report - {shop.shop_name}"])
        ws.merge_cells('A1:F1')
        ws['A1'].font = Font(bold=True, size=14)
        ws['A1'].alignment = Alignment(horizontal='center')

        if start_date and end_date:
            ws.append([f"Period: {start_date} to {end_date}"])
            ws.merge_cells('A2:F2')
            ws['A2'].alignment = Alignment(horizontal='center')

        ws.append([])  # Empty row

        # Summary section
        ws.append(["Summary", "Amount (৳)"])
        ws.append(["Total Credit (In)", float(summary['total_credit'])])
        ws.append(["Total Debit (Out)", float(summary['total_debit'])])
        ws.append(["Net Balance", float(summary['total_credit'] - summary['total_debit'])])

        ws.append([])  # Empty row

        # Transaction details header
        headers = ["Date", "Type", "Source", "Description", "Credit (৳)", "Debit (৳)", "Payment Method", "Reference"]
        ws.append(headers)
        header_row = ws.max_row
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=header_row, column=col)
            cell.font = header_font
            cell.fill = green_fill
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        # Transaction data
        for t in queryset:
            credit = float(t.amount) if t.transaction_type == 'credit' else ""
            debit = float(t.amount) if t.transaction_type == 'debit' else ""

            ws.append([
                str(t.date),
                t.get_transaction_type_display(),
                t.get_source_display(),
                t.description or t.get_source_display(),
                credit,
                debit,
                t.get_payment_method_display(),
                t.reference_no or ""
            ])

        # Adjust column widths
        ws.column_dimensions['A'].width = 12
        ws.column_dimensions['B'].width = 10
        ws.column_dimensions['C'].width = 18
        ws.column_dimensions['D'].width = 35
        ws.column_dimensions['E'].width = 12
        ws.column_dimensions['F'].width = 12
        ws.column_dimensions['G'].width = 15
        ws.column_dimensions['H'].width = 15

        # Save to buffer
        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)

        response = HttpResponse(
            buffer,
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        response["Content-Disposition"] = f'attachment; filename="cash_ledger_{start_date or "all"}_{end_date or "all"}.xlsx"'
        return response

